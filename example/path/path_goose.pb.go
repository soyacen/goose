// Code generated by protoc-gen-goose. DO NOT EDIT.

package path

import (
	bytes "bytes"
	context "context"
	errors "errors"
	goose "github.com/soyacen/goose"
	client "github.com/soyacen/goose/client"
	resolver "github.com/soyacen/goose/client/resolver"
	server "github.com/soyacen/goose/server"
	httpbody "google.golang.org/genproto/googleapis/api/httpbody"
	protojson "google.golang.org/protobuf/encoding/protojson"
	proto "google.golang.org/protobuf/proto"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	http "net/http"
	url "net/url"
)

type BoolPathService interface {
	BoolPath(ctx context.Context, req *BoolPathRequest) (*httpbody.HttpBody, error)
}

func AppendBoolPathRoute(router *http.ServeMux, service BoolPathService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := boolPathHandler{
		service: service,
		decoder: boolPathRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: boolPathResponseEncoder{
			marshalOptions:   options.MarshalOptions(),
			unmarshalOptions: options.UnmarshalOptions(),
		},
		errorEncoder:            options.ErrorEncoder(),
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              server.Chain(options.Middlewares()...),
	}
	router.Handle("GET /v1/{bool}/{opt_bool}/{wrap_bool}", http.HandlerFunc(handler.BoolPath))
	return router
}

type boolPathHandler struct {
	service                 BoolPathService
	decoder                 boolPathRequestDecoder
	encoder                 boolPathResponseEncoder
	errorEncoder            goose.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              server.Middleware
}

func (h boolPathHandler) BoolPath(response http.ResponseWriter, request *http.Request) {
	invoke := func(response http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		req, err := h.decoder.BoolPath(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := goose.ValidateRequest(ctx, req, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		resp, err := h.service.BoolPath(ctx, req)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := h.encoder.BoolPath(ctx, response, resp); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
	}
	server.Invoke(h.middleware, response, request, invoke)
}

type boolPathRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder boolPathRequestDecoder) BoolPath(ctx context.Context, request *http.Request) (*BoolPathRequest, error) {
	req := &BoolPathRequest{}
	ok, err := server.CustomDecodeRequest(ctx, request, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := goose.FormFromPath(request, "bool", "opt_bool", "wrap_bool")
	var varErr error
	req.Bool, varErr = goose.GetForm[bool](varErr, vars, "bool", goose.GetBool)
	req.OptBool, varErr = goose.GetForm[*bool](varErr, vars, "opt_bool", goose.GetBoolPtr)
	req.WrapBool, varErr = goose.GetForm[*wrapperspb.BoolValue](varErr, vars, "wrap_bool", goose.GetBoolValue)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type boolPathResponseEncoder struct {
	marshalOptions   protojson.MarshalOptions
	unmarshalOptions protojson.UnmarshalOptions
}

func (encoder boolPathResponseEncoder) BoolPath(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

func NewBoolPathClient(target string, opts ...client.Option) BoolPathService {
	options := client.NewOptions(opts...)
	client := &boolPathClient{
		client: options.Client(),
		encoder: boolPathRequestEncoder{
			target:         target,
			marshalOptions: options.MarshalOptions(),
			resolver:       options.Resolver(),
		},
		decoder: boolPathResponseDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
			errorDecoder:     options.ErrorDecoder(),
			errorFactory:     options.ErrorFactory(),
		},
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              client.Chain(options.Middlewares()...),
	}
	return client
}

type boolPathClient struct {
	client                  *http.Client
	encoder                 boolPathRequestEncoder
	decoder                 boolPathResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              client.Middleware
}

func (c *boolPathClient) BoolPath(ctx context.Context, req *BoolPathRequest) (*httpbody.HttpBody, error) {
	if err := goose.ValidateRequest(ctx, req, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	request, err := c.encoder.BoolPath(ctx, req)
	if err != nil {
		return nil, err
	}
	response, err := client.Invoke(c.middleware, c.client, request)
	if err != nil {
		return nil, err
	}
	resp, err := c.decoder.BoolPath(ctx, response)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type boolPathRequestEncoder struct {
	target         string
	marshalOptions protojson.MarshalOptions
	resolver       resolver.Resolver
}

func (encoder *boolPathRequestEncoder) BoolPath(ctx context.Context, req *BoolPathRequest) (*http.Request, error) {
	if req == nil {
		return nil, errors.New("request is nil")
	}
	target, err := resolver.Resolve(ctx, encoder.resolver, encoder.target)
	if err != nil {
		return nil, err
	}
	method := "GET"
	header := http.Header{}
	var body bytes.Buffer
	path := "/v1/{bool}/{opt_bool}/{wrap_bool}"
	pairs := map[string]string{
		"bool":      goose.FormatBool(req.GetBool()),
		"opt_bool":  goose.FormatBool(req.GetOptBool()),
		"wrap_bool": goose.FormatBool(req.GetWrapBool().GetValue()),
	}
	path = goose.URLPath(path, pairs)
	path, err = url.JoinPath(target.Path, path)
	if err != nil {
		return nil, err
	}
	target.Path = path
	request, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
	if err != nil {
		return nil, err
	}
	goose.CopyHeader(request.Header, header)
	return request, nil
}

type boolPathResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
	errorDecoder     goose.ErrorDecoder
	errorFactory     goose.ErrorFactory
}

func (decoder *boolPathResponseDecoder) BoolPath(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	if respErr, ok := decoder.errorDecoder(ctx, response, decoder.errorFactory); ok {
		return nil, respErr
	}
	resp := &httpbody.HttpBody{}
	if err := client.DecodeHttpBody(ctx, response, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

type Int32PathService interface {
	Int32Path(ctx context.Context, req *Int32PathRequest) (*httpbody.HttpBody, error)
}

func AppendInt32PathRoute(router *http.ServeMux, service Int32PathService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := int32PathHandler{
		service: service,
		decoder: int32PathRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: int32PathResponseEncoder{
			marshalOptions:   options.MarshalOptions(),
			unmarshalOptions: options.UnmarshalOptions(),
		},
		errorEncoder:            options.ErrorEncoder(),
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              server.Chain(options.Middlewares()...),
	}
	router.Handle("GET /v1/{int32}/{sint32}/{sfixed32}/{opt_int32}/{opt_sint32}/{opt_sfixed32}/{wrap_int32}", http.HandlerFunc(handler.Int32Path))
	return router
}

type int32PathHandler struct {
	service                 Int32PathService
	decoder                 int32PathRequestDecoder
	encoder                 int32PathResponseEncoder
	errorEncoder            goose.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              server.Middleware
}

func (h int32PathHandler) Int32Path(response http.ResponseWriter, request *http.Request) {
	invoke := func(response http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		req, err := h.decoder.Int32Path(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := goose.ValidateRequest(ctx, req, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		resp, err := h.service.Int32Path(ctx, req)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := h.encoder.Int32Path(ctx, response, resp); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
	}
	server.Invoke(h.middleware, response, request, invoke)
}

type int32PathRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int32PathRequestDecoder) Int32Path(ctx context.Context, request *http.Request) (*Int32PathRequest, error) {
	req := &Int32PathRequest{}
	ok, err := server.CustomDecodeRequest(ctx, request, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := goose.FormFromPath(request, "int32", "sint32", "sfixed32", "opt_int32", "opt_sint32", "opt_sfixed32", "wrap_int32")
	var varErr error
	req.Int32, varErr = goose.GetForm[int32](varErr, vars, "int32", goose.GetInt)
	req.Sint32, varErr = goose.GetForm[int32](varErr, vars, "sint32", goose.GetInt)
	req.Sfixed32, varErr = goose.GetForm[int32](varErr, vars, "sfixed32", goose.GetInt)
	req.OptInt32, varErr = goose.GetForm[*int32](varErr, vars, "opt_int32", goose.GetIntPtr)
	req.OptSint32, varErr = goose.GetForm[*int32](varErr, vars, "opt_sint32", goose.GetIntPtr)
	req.OptSfixed32, varErr = goose.GetForm[*int32](varErr, vars, "opt_sfixed32", goose.GetIntPtr)
	req.WrapInt32, varErr = goose.GetForm[*wrapperspb.Int32Value](varErr, vars, "wrap_int32", goose.GetInt32Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type int32PathResponseEncoder struct {
	marshalOptions   protojson.MarshalOptions
	unmarshalOptions protojson.UnmarshalOptions
}

func (encoder int32PathResponseEncoder) Int32Path(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

func NewInt32PathClient(target string, opts ...client.Option) Int32PathService {
	options := client.NewOptions(opts...)
	client := &int32PathClient{
		client: options.Client(),
		encoder: int32PathRequestEncoder{
			target:         target,
			marshalOptions: options.MarshalOptions(),
			resolver:       options.Resolver(),
		},
		decoder: int32PathResponseDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
			errorDecoder:     options.ErrorDecoder(),
			errorFactory:     options.ErrorFactory(),
		},
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              client.Chain(options.Middlewares()...),
	}
	return client
}

type int32PathClient struct {
	client                  *http.Client
	encoder                 int32PathRequestEncoder
	decoder                 int32PathResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              client.Middleware
}

func (c *int32PathClient) Int32Path(ctx context.Context, req *Int32PathRequest) (*httpbody.HttpBody, error) {
	if err := goose.ValidateRequest(ctx, req, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	request, err := c.encoder.Int32Path(ctx, req)
	if err != nil {
		return nil, err
	}
	response, err := client.Invoke(c.middleware, c.client, request)
	if err != nil {
		return nil, err
	}
	resp, err := c.decoder.Int32Path(ctx, response)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type int32PathRequestEncoder struct {
	target         string
	marshalOptions protojson.MarshalOptions
	resolver       resolver.Resolver
}

func (encoder *int32PathRequestEncoder) Int32Path(ctx context.Context, req *Int32PathRequest) (*http.Request, error) {
	if req == nil {
		return nil, errors.New("request is nil")
	}
	target, err := resolver.Resolve(ctx, encoder.resolver, encoder.target)
	if err != nil {
		return nil, err
	}
	method := "GET"
	header := http.Header{}
	var body bytes.Buffer
	path := "/v1/{int32}/{sint32}/{sfixed32}/{opt_int32}/{opt_sint32}/{opt_sfixed32}/{wrap_int32}"
	pairs := map[string]string{
		"int32":        goose.FormatInt(req.GetInt32(), 10),
		"sint32":       goose.FormatInt(req.GetSint32(), 10),
		"sfixed32":     goose.FormatInt(req.GetSfixed32(), 10),
		"opt_int32":    goose.FormatInt(req.GetOptInt32(), 10),
		"opt_sint32":   goose.FormatInt(req.GetOptSint32(), 10),
		"opt_sfixed32": goose.FormatInt(req.GetOptSfixed32(), 10),
		"wrap_int32":   goose.FormatInt(req.GetWrapInt32().GetValue(), 10),
	}
	path = goose.URLPath(path, pairs)
	path, err = url.JoinPath(target.Path, path)
	if err != nil {
		return nil, err
	}
	target.Path = path
	request, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
	if err != nil {
		return nil, err
	}
	goose.CopyHeader(request.Header, header)
	return request, nil
}

type int32PathResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
	errorDecoder     goose.ErrorDecoder
	errorFactory     goose.ErrorFactory
}

func (decoder *int32PathResponseDecoder) Int32Path(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	if respErr, ok := decoder.errorDecoder(ctx, response, decoder.errorFactory); ok {
		return nil, respErr
	}
	resp := &httpbody.HttpBody{}
	if err := client.DecodeHttpBody(ctx, response, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

type Int64PathService interface {
	Int64Path(ctx context.Context, req *Int64PathRequest) (*httpbody.HttpBody, error)
}

func AppendInt64PathRoute(router *http.ServeMux, service Int64PathService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := int64PathHandler{
		service: service,
		decoder: int64PathRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: int64PathResponseEncoder{
			marshalOptions:   options.MarshalOptions(),
			unmarshalOptions: options.UnmarshalOptions(),
		},
		errorEncoder:            options.ErrorEncoder(),
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              server.Chain(options.Middlewares()...),
	}
	router.Handle("GET /v1/{int64}/{sint64}/{sfixed64}/{opt_int64}/{opt_sint64}/{opt_sfixed64}/{wrap_int64}", http.HandlerFunc(handler.Int64Path))
	return router
}

type int64PathHandler struct {
	service                 Int64PathService
	decoder                 int64PathRequestDecoder
	encoder                 int64PathResponseEncoder
	errorEncoder            goose.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              server.Middleware
}

func (h int64PathHandler) Int64Path(response http.ResponseWriter, request *http.Request) {
	invoke := func(response http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		req, err := h.decoder.Int64Path(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := goose.ValidateRequest(ctx, req, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		resp, err := h.service.Int64Path(ctx, req)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := h.encoder.Int64Path(ctx, response, resp); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
	}
	server.Invoke(h.middleware, response, request, invoke)
}

type int64PathRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int64PathRequestDecoder) Int64Path(ctx context.Context, request *http.Request) (*Int64PathRequest, error) {
	req := &Int64PathRequest{}
	ok, err := server.CustomDecodeRequest(ctx, request, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := goose.FormFromPath(request, "int64", "sint64", "sfixed64", "opt_int64", "opt_sint64", "opt_sfixed64", "wrap_int64")
	var varErr error
	req.Int64, varErr = goose.GetForm[int64](varErr, vars, "int64", goose.GetInt)
	req.Sint64, varErr = goose.GetForm[int64](varErr, vars, "sint64", goose.GetInt)
	req.Sfixed64, varErr = goose.GetForm[int64](varErr, vars, "sfixed64", goose.GetInt)
	req.OptInt64, varErr = goose.GetForm[*int64](varErr, vars, "opt_int64", goose.GetIntPtr)
	req.OptSint64, varErr = goose.GetForm[*int64](varErr, vars, "opt_sint64", goose.GetIntPtr)
	req.OptSfixed64, varErr = goose.GetForm[*int64](varErr, vars, "opt_sfixed64", goose.GetIntPtr)
	req.WrapInt64, varErr = goose.GetForm[*wrapperspb.Int64Value](varErr, vars, "wrap_int64", goose.GetInt64Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type int64PathResponseEncoder struct {
	marshalOptions   protojson.MarshalOptions
	unmarshalOptions protojson.UnmarshalOptions
}

func (encoder int64PathResponseEncoder) Int64Path(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

func NewInt64PathClient(target string, opts ...client.Option) Int64PathService {
	options := client.NewOptions(opts...)
	client := &int64PathClient{
		client: options.Client(),
		encoder: int64PathRequestEncoder{
			target:         target,
			marshalOptions: options.MarshalOptions(),
			resolver:       options.Resolver(),
		},
		decoder: int64PathResponseDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
			errorDecoder:     options.ErrorDecoder(),
			errorFactory:     options.ErrorFactory(),
		},
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              client.Chain(options.Middlewares()...),
	}
	return client
}

type int64PathClient struct {
	client                  *http.Client
	encoder                 int64PathRequestEncoder
	decoder                 int64PathResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              client.Middleware
}

func (c *int64PathClient) Int64Path(ctx context.Context, req *Int64PathRequest) (*httpbody.HttpBody, error) {
	if err := goose.ValidateRequest(ctx, req, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	request, err := c.encoder.Int64Path(ctx, req)
	if err != nil {
		return nil, err
	}
	response, err := client.Invoke(c.middleware, c.client, request)
	if err != nil {
		return nil, err
	}
	resp, err := c.decoder.Int64Path(ctx, response)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type int64PathRequestEncoder struct {
	target         string
	marshalOptions protojson.MarshalOptions
	resolver       resolver.Resolver
}

func (encoder *int64PathRequestEncoder) Int64Path(ctx context.Context, req *Int64PathRequest) (*http.Request, error) {
	if req == nil {
		return nil, errors.New("request is nil")
	}
	target, err := resolver.Resolve(ctx, encoder.resolver, encoder.target)
	if err != nil {
		return nil, err
	}
	method := "GET"
	header := http.Header{}
	var body bytes.Buffer
	path := "/v1/{int64}/{sint64}/{sfixed64}/{opt_int64}/{opt_sint64}/{opt_sfixed64}/{wrap_int64}"
	pairs := map[string]string{
		"int64":        goose.FormatInt(req.GetInt64(), 10),
		"sint64":       goose.FormatInt(req.GetSint64(), 10),
		"sfixed64":     goose.FormatInt(req.GetSfixed64(), 10),
		"opt_int64":    goose.FormatInt(req.GetOptInt64(), 10),
		"opt_sint64":   goose.FormatInt(req.GetOptSint64(), 10),
		"opt_sfixed64": goose.FormatInt(req.GetOptSfixed64(), 10),
		"wrap_int64":   goose.FormatInt(req.GetWrapInt64().GetValue(), 10),
	}
	path = goose.URLPath(path, pairs)
	path, err = url.JoinPath(target.Path, path)
	if err != nil {
		return nil, err
	}
	target.Path = path
	request, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
	if err != nil {
		return nil, err
	}
	goose.CopyHeader(request.Header, header)
	return request, nil
}

type int64PathResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
	errorDecoder     goose.ErrorDecoder
	errorFactory     goose.ErrorFactory
}

func (decoder *int64PathResponseDecoder) Int64Path(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	if respErr, ok := decoder.errorDecoder(ctx, response, decoder.errorFactory); ok {
		return nil, respErr
	}
	resp := &httpbody.HttpBody{}
	if err := client.DecodeHttpBody(ctx, response, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

type Uint32PathService interface {
	Uint32Path(ctx context.Context, req *Uint32PathRequest) (*httpbody.HttpBody, error)
}

func AppendUint32PathRoute(router *http.ServeMux, service Uint32PathService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := uint32PathHandler{
		service: service,
		decoder: uint32PathRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: uint32PathResponseEncoder{
			marshalOptions:   options.MarshalOptions(),
			unmarshalOptions: options.UnmarshalOptions(),
		},
		errorEncoder:            options.ErrorEncoder(),
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              server.Chain(options.Middlewares()...),
	}
	router.Handle("GET /v1/{uint32}/{fixed32}/{opt_uint32}/{opt_fixed32}/{wrap_uint32}", http.HandlerFunc(handler.Uint32Path))
	return router
}

type uint32PathHandler struct {
	service                 Uint32PathService
	decoder                 uint32PathRequestDecoder
	encoder                 uint32PathResponseEncoder
	errorEncoder            goose.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              server.Middleware
}

func (h uint32PathHandler) Uint32Path(response http.ResponseWriter, request *http.Request) {
	invoke := func(response http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		req, err := h.decoder.Uint32Path(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := goose.ValidateRequest(ctx, req, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		resp, err := h.service.Uint32Path(ctx, req)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := h.encoder.Uint32Path(ctx, response, resp); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
	}
	server.Invoke(h.middleware, response, request, invoke)
}

type uint32PathRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint32PathRequestDecoder) Uint32Path(ctx context.Context, request *http.Request) (*Uint32PathRequest, error) {
	req := &Uint32PathRequest{}
	ok, err := server.CustomDecodeRequest(ctx, request, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := goose.FormFromPath(request, "uint32", "fixed32", "opt_uint32", "opt_fixed32", "wrap_uint32")
	var varErr error
	req.Uint32, varErr = goose.GetForm[uint32](varErr, vars, "uint32", goose.GetUint)
	req.Fixed32, varErr = goose.GetForm[uint32](varErr, vars, "fixed32", goose.GetUint)
	req.OptUint32, varErr = goose.GetForm[*uint32](varErr, vars, "opt_uint32", goose.GetUintPtr)
	req.OptFixed32, varErr = goose.GetForm[*uint32](varErr, vars, "opt_fixed32", goose.GetUintPtr)
	req.WrapUint32, varErr = goose.GetForm[*wrapperspb.UInt32Value](varErr, vars, "wrap_uint32", goose.GetUint32Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type uint32PathResponseEncoder struct {
	marshalOptions   protojson.MarshalOptions
	unmarshalOptions protojson.UnmarshalOptions
}

func (encoder uint32PathResponseEncoder) Uint32Path(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

func NewUint32PathClient(target string, opts ...client.Option) Uint32PathService {
	options := client.NewOptions(opts...)
	client := &uint32PathClient{
		client: options.Client(),
		encoder: uint32PathRequestEncoder{
			target:         target,
			marshalOptions: options.MarshalOptions(),
			resolver:       options.Resolver(),
		},
		decoder: uint32PathResponseDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
			errorDecoder:     options.ErrorDecoder(),
			errorFactory:     options.ErrorFactory(),
		},
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              client.Chain(options.Middlewares()...),
	}
	return client
}

type uint32PathClient struct {
	client                  *http.Client
	encoder                 uint32PathRequestEncoder
	decoder                 uint32PathResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              client.Middleware
}

func (c *uint32PathClient) Uint32Path(ctx context.Context, req *Uint32PathRequest) (*httpbody.HttpBody, error) {
	if err := goose.ValidateRequest(ctx, req, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	request, err := c.encoder.Uint32Path(ctx, req)
	if err != nil {
		return nil, err
	}
	response, err := client.Invoke(c.middleware, c.client, request)
	if err != nil {
		return nil, err
	}
	resp, err := c.decoder.Uint32Path(ctx, response)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type uint32PathRequestEncoder struct {
	target         string
	marshalOptions protojson.MarshalOptions
	resolver       resolver.Resolver
}

func (encoder *uint32PathRequestEncoder) Uint32Path(ctx context.Context, req *Uint32PathRequest) (*http.Request, error) {
	if req == nil {
		return nil, errors.New("request is nil")
	}
	target, err := resolver.Resolve(ctx, encoder.resolver, encoder.target)
	if err != nil {
		return nil, err
	}
	method := "GET"
	header := http.Header{}
	var body bytes.Buffer
	path := "/v1/{uint32}/{fixed32}/{opt_uint32}/{opt_fixed32}/{wrap_uint32}"
	pairs := map[string]string{
		"uint32":      goose.FormatUint(req.GetUint32(), 10),
		"fixed32":     goose.FormatUint(req.GetFixed32(), 10),
		"opt_uint32":  goose.FormatUint(req.GetOptUint32(), 10),
		"opt_fixed32": goose.FormatUint(req.GetOptFixed32(), 10),
		"wrap_uint32": goose.FormatUint(req.GetWrapUint32().GetValue(), 10),
	}
	path = goose.URLPath(path, pairs)
	path, err = url.JoinPath(target.Path, path)
	if err != nil {
		return nil, err
	}
	target.Path = path
	request, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
	if err != nil {
		return nil, err
	}
	goose.CopyHeader(request.Header, header)
	return request, nil
}

type uint32PathResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
	errorDecoder     goose.ErrorDecoder
	errorFactory     goose.ErrorFactory
}

func (decoder *uint32PathResponseDecoder) Uint32Path(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	if respErr, ok := decoder.errorDecoder(ctx, response, decoder.errorFactory); ok {
		return nil, respErr
	}
	resp := &httpbody.HttpBody{}
	if err := client.DecodeHttpBody(ctx, response, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

type Uint64PathService interface {
	Uint64Path(ctx context.Context, req *Uint64PathRequest) (*httpbody.HttpBody, error)
}

func AppendUint64PathRoute(router *http.ServeMux, service Uint64PathService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := uint64PathHandler{
		service: service,
		decoder: uint64PathRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: uint64PathResponseEncoder{
			marshalOptions:   options.MarshalOptions(),
			unmarshalOptions: options.UnmarshalOptions(),
		},
		errorEncoder:            options.ErrorEncoder(),
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              server.Chain(options.Middlewares()...),
	}
	router.Handle("GET /v1/{uint64}/{fixed64}/{opt_uint64}/{opt_fixed64}/{wrap_uint64}", http.HandlerFunc(handler.Uint64Path))
	return router
}

type uint64PathHandler struct {
	service                 Uint64PathService
	decoder                 uint64PathRequestDecoder
	encoder                 uint64PathResponseEncoder
	errorEncoder            goose.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              server.Middleware
}

func (h uint64PathHandler) Uint64Path(response http.ResponseWriter, request *http.Request) {
	invoke := func(response http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		req, err := h.decoder.Uint64Path(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := goose.ValidateRequest(ctx, req, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		resp, err := h.service.Uint64Path(ctx, req)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := h.encoder.Uint64Path(ctx, response, resp); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
	}
	server.Invoke(h.middleware, response, request, invoke)
}

type uint64PathRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint64PathRequestDecoder) Uint64Path(ctx context.Context, request *http.Request) (*Uint64PathRequest, error) {
	req := &Uint64PathRequest{}
	ok, err := server.CustomDecodeRequest(ctx, request, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := goose.FormFromPath(request, "uint64", "fixed64", "opt_uint64", "opt_fixed64", "wrap_uint64")
	var varErr error
	req.Uint64, varErr = goose.GetForm[uint64](varErr, vars, "uint64", goose.GetUint)
	req.Fixed64, varErr = goose.GetForm[uint64](varErr, vars, "fixed64", goose.GetUint)
	req.OptUint64, varErr = goose.GetForm[*uint64](varErr, vars, "opt_uint64", goose.GetUintPtr)
	req.OptFixed64, varErr = goose.GetForm[*uint64](varErr, vars, "opt_fixed64", goose.GetUintPtr)
	req.WrapUint64, varErr = goose.GetForm[*wrapperspb.UInt64Value](varErr, vars, "wrap_uint64", goose.GetUint64Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type uint64PathResponseEncoder struct {
	marshalOptions   protojson.MarshalOptions
	unmarshalOptions protojson.UnmarshalOptions
}

func (encoder uint64PathResponseEncoder) Uint64Path(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

func NewUint64PathClient(target string, opts ...client.Option) Uint64PathService {
	options := client.NewOptions(opts...)
	client := &uint64PathClient{
		client: options.Client(),
		encoder: uint64PathRequestEncoder{
			target:         target,
			marshalOptions: options.MarshalOptions(),
			resolver:       options.Resolver(),
		},
		decoder: uint64PathResponseDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
			errorDecoder:     options.ErrorDecoder(),
			errorFactory:     options.ErrorFactory(),
		},
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              client.Chain(options.Middlewares()...),
	}
	return client
}

type uint64PathClient struct {
	client                  *http.Client
	encoder                 uint64PathRequestEncoder
	decoder                 uint64PathResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              client.Middleware
}

func (c *uint64PathClient) Uint64Path(ctx context.Context, req *Uint64PathRequest) (*httpbody.HttpBody, error) {
	if err := goose.ValidateRequest(ctx, req, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	request, err := c.encoder.Uint64Path(ctx, req)
	if err != nil {
		return nil, err
	}
	response, err := client.Invoke(c.middleware, c.client, request)
	if err != nil {
		return nil, err
	}
	resp, err := c.decoder.Uint64Path(ctx, response)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type uint64PathRequestEncoder struct {
	target         string
	marshalOptions protojson.MarshalOptions
	resolver       resolver.Resolver
}

func (encoder *uint64PathRequestEncoder) Uint64Path(ctx context.Context, req *Uint64PathRequest) (*http.Request, error) {
	if req == nil {
		return nil, errors.New("request is nil")
	}
	target, err := resolver.Resolve(ctx, encoder.resolver, encoder.target)
	if err != nil {
		return nil, err
	}
	method := "GET"
	header := http.Header{}
	var body bytes.Buffer
	path := "/v1/{uint64}/{fixed64}/{opt_uint64}/{opt_fixed64}/{wrap_uint64}"
	pairs := map[string]string{
		"uint64":      goose.FormatUint(req.GetUint64(), 10),
		"fixed64":     goose.FormatUint(req.GetFixed64(), 10),
		"opt_uint64":  goose.FormatUint(req.GetOptUint64(), 10),
		"opt_fixed64": goose.FormatUint(req.GetOptFixed64(), 10),
		"wrap_uint64": goose.FormatUint(req.GetWrapUint64().GetValue(), 10),
	}
	path = goose.URLPath(path, pairs)
	path, err = url.JoinPath(target.Path, path)
	if err != nil {
		return nil, err
	}
	target.Path = path
	request, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
	if err != nil {
		return nil, err
	}
	goose.CopyHeader(request.Header, header)
	return request, nil
}

type uint64PathResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
	errorDecoder     goose.ErrorDecoder
	errorFactory     goose.ErrorFactory
}

func (decoder *uint64PathResponseDecoder) Uint64Path(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	if respErr, ok := decoder.errorDecoder(ctx, response, decoder.errorFactory); ok {
		return nil, respErr
	}
	resp := &httpbody.HttpBody{}
	if err := client.DecodeHttpBody(ctx, response, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

type FloatPathService interface {
	FloatPath(ctx context.Context, req *FloatPathRequest) (*httpbody.HttpBody, error)
}

func AppendFloatPathRoute(router *http.ServeMux, service FloatPathService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := floatPathHandler{
		service: service,
		decoder: floatPathRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: floatPathResponseEncoder{
			marshalOptions:   options.MarshalOptions(),
			unmarshalOptions: options.UnmarshalOptions(),
		},
		errorEncoder:            options.ErrorEncoder(),
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              server.Chain(options.Middlewares()...),
	}
	router.Handle("GET /v1/{float}/{opt_float}/{wrap_float}", http.HandlerFunc(handler.FloatPath))
	return router
}

type floatPathHandler struct {
	service                 FloatPathService
	decoder                 floatPathRequestDecoder
	encoder                 floatPathResponseEncoder
	errorEncoder            goose.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              server.Middleware
}

func (h floatPathHandler) FloatPath(response http.ResponseWriter, request *http.Request) {
	invoke := func(response http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		req, err := h.decoder.FloatPath(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := goose.ValidateRequest(ctx, req, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		resp, err := h.service.FloatPath(ctx, req)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := h.encoder.FloatPath(ctx, response, resp); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
	}
	server.Invoke(h.middleware, response, request, invoke)
}

type floatPathRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder floatPathRequestDecoder) FloatPath(ctx context.Context, request *http.Request) (*FloatPathRequest, error) {
	req := &FloatPathRequest{}
	ok, err := server.CustomDecodeRequest(ctx, request, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := goose.FormFromPath(request, "float", "opt_float", "wrap_float")
	var varErr error
	req.Float, varErr = goose.GetForm[float32](varErr, vars, "float", goose.GetFloat)
	req.OptFloat, varErr = goose.GetForm[*float32](varErr, vars, "opt_float", goose.GetFloatPtr)
	req.WrapFloat, varErr = goose.GetForm[*wrapperspb.FloatValue](varErr, vars, "wrap_float", goose.GetFloat32Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type floatPathResponseEncoder struct {
	marshalOptions   protojson.MarshalOptions
	unmarshalOptions protojson.UnmarshalOptions
}

func (encoder floatPathResponseEncoder) FloatPath(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

func NewFloatPathClient(target string, opts ...client.Option) FloatPathService {
	options := client.NewOptions(opts...)
	client := &floatPathClient{
		client: options.Client(),
		encoder: floatPathRequestEncoder{
			target:         target,
			marshalOptions: options.MarshalOptions(),
			resolver:       options.Resolver(),
		},
		decoder: floatPathResponseDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
			errorDecoder:     options.ErrorDecoder(),
			errorFactory:     options.ErrorFactory(),
		},
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              client.Chain(options.Middlewares()...),
	}
	return client
}

type floatPathClient struct {
	client                  *http.Client
	encoder                 floatPathRequestEncoder
	decoder                 floatPathResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              client.Middleware
}

func (c *floatPathClient) FloatPath(ctx context.Context, req *FloatPathRequest) (*httpbody.HttpBody, error) {
	if err := goose.ValidateRequest(ctx, req, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	request, err := c.encoder.FloatPath(ctx, req)
	if err != nil {
		return nil, err
	}
	response, err := client.Invoke(c.middleware, c.client, request)
	if err != nil {
		return nil, err
	}
	resp, err := c.decoder.FloatPath(ctx, response)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type floatPathRequestEncoder struct {
	target         string
	marshalOptions protojson.MarshalOptions
	resolver       resolver.Resolver
}

func (encoder *floatPathRequestEncoder) FloatPath(ctx context.Context, req *FloatPathRequest) (*http.Request, error) {
	if req == nil {
		return nil, errors.New("request is nil")
	}
	target, err := resolver.Resolve(ctx, encoder.resolver, encoder.target)
	if err != nil {
		return nil, err
	}
	method := "GET"
	header := http.Header{}
	var body bytes.Buffer
	path := "/v1/{float}/{opt_float}/{wrap_float}"
	pairs := map[string]string{
		"float":      goose.FormatFloat(req.GetFloat(), 'f', -1, 32),
		"opt_float":  goose.FormatFloat(req.GetOptFloat(), 'f', -1, 32),
		"wrap_float": goose.FormatFloat(req.GetWrapFloat().GetValue(), 'f', -1, 32),
	}
	path = goose.URLPath(path, pairs)
	path, err = url.JoinPath(target.Path, path)
	if err != nil {
		return nil, err
	}
	target.Path = path
	request, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
	if err != nil {
		return nil, err
	}
	goose.CopyHeader(request.Header, header)
	return request, nil
}

type floatPathResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
	errorDecoder     goose.ErrorDecoder
	errorFactory     goose.ErrorFactory
}

func (decoder *floatPathResponseDecoder) FloatPath(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	if respErr, ok := decoder.errorDecoder(ctx, response, decoder.errorFactory); ok {
		return nil, respErr
	}
	resp := &httpbody.HttpBody{}
	if err := client.DecodeHttpBody(ctx, response, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

type DoublePathService interface {
	DoublePath(ctx context.Context, req *DoublePathRequest) (*httpbody.HttpBody, error)
}

func AppendDoublePathRoute(router *http.ServeMux, service DoublePathService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := doublePathHandler{
		service: service,
		decoder: doublePathRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: doublePathResponseEncoder{
			marshalOptions:   options.MarshalOptions(),
			unmarshalOptions: options.UnmarshalOptions(),
		},
		errorEncoder:            options.ErrorEncoder(),
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              server.Chain(options.Middlewares()...),
	}
	router.Handle("GET /v1/{double}/{opt_double}/{wrap_double}", http.HandlerFunc(handler.DoublePath))
	return router
}

type doublePathHandler struct {
	service                 DoublePathService
	decoder                 doublePathRequestDecoder
	encoder                 doublePathResponseEncoder
	errorEncoder            goose.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              server.Middleware
}

func (h doublePathHandler) DoublePath(response http.ResponseWriter, request *http.Request) {
	invoke := func(response http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		req, err := h.decoder.DoublePath(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := goose.ValidateRequest(ctx, req, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		resp, err := h.service.DoublePath(ctx, req)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := h.encoder.DoublePath(ctx, response, resp); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
	}
	server.Invoke(h.middleware, response, request, invoke)
}

type doublePathRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder doublePathRequestDecoder) DoublePath(ctx context.Context, request *http.Request) (*DoublePathRequest, error) {
	req := &DoublePathRequest{}
	ok, err := server.CustomDecodeRequest(ctx, request, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := goose.FormFromPath(request, "double", "opt_double", "wrap_double")
	var varErr error
	req.Double, varErr = goose.GetForm[float64](varErr, vars, "double", goose.GetFloat)
	req.OptDouble, varErr = goose.GetForm[*float64](varErr, vars, "opt_double", goose.GetFloatPtr)
	req.WrapDouble, varErr = goose.GetForm[*wrapperspb.DoubleValue](varErr, vars, "wrap_double", goose.GetFloat64Value)
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type doublePathResponseEncoder struct {
	marshalOptions   protojson.MarshalOptions
	unmarshalOptions protojson.UnmarshalOptions
}

func (encoder doublePathResponseEncoder) DoublePath(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

func NewDoublePathClient(target string, opts ...client.Option) DoublePathService {
	options := client.NewOptions(opts...)
	client := &doublePathClient{
		client: options.Client(),
		encoder: doublePathRequestEncoder{
			target:         target,
			marshalOptions: options.MarshalOptions(),
			resolver:       options.Resolver(),
		},
		decoder: doublePathResponseDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
			errorDecoder:     options.ErrorDecoder(),
			errorFactory:     options.ErrorFactory(),
		},
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              client.Chain(options.Middlewares()...),
	}
	return client
}

type doublePathClient struct {
	client                  *http.Client
	encoder                 doublePathRequestEncoder
	decoder                 doublePathResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              client.Middleware
}

func (c *doublePathClient) DoublePath(ctx context.Context, req *DoublePathRequest) (*httpbody.HttpBody, error) {
	if err := goose.ValidateRequest(ctx, req, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	request, err := c.encoder.DoublePath(ctx, req)
	if err != nil {
		return nil, err
	}
	response, err := client.Invoke(c.middleware, c.client, request)
	if err != nil {
		return nil, err
	}
	resp, err := c.decoder.DoublePath(ctx, response)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type doublePathRequestEncoder struct {
	target         string
	marshalOptions protojson.MarshalOptions
	resolver       resolver.Resolver
}

func (encoder *doublePathRequestEncoder) DoublePath(ctx context.Context, req *DoublePathRequest) (*http.Request, error) {
	if req == nil {
		return nil, errors.New("request is nil")
	}
	target, err := resolver.Resolve(ctx, encoder.resolver, encoder.target)
	if err != nil {
		return nil, err
	}
	method := "GET"
	header := http.Header{}
	var body bytes.Buffer
	path := "/v1/{double}/{opt_double}/{wrap_double}"
	pairs := map[string]string{
		"double":      goose.FormatFloat(req.GetDouble(), 'f', -1, 64),
		"opt_double":  goose.FormatFloat(req.GetOptDouble(), 'f', -1, 64),
		"wrap_double": goose.FormatFloat(req.GetWrapDouble().GetValue(), 'f', -1, 64),
	}
	path = goose.URLPath(path, pairs)
	path, err = url.JoinPath(target.Path, path)
	if err != nil {
		return nil, err
	}
	target.Path = path
	request, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
	if err != nil {
		return nil, err
	}
	goose.CopyHeader(request.Header, header)
	return request, nil
}

type doublePathResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
	errorDecoder     goose.ErrorDecoder
	errorFactory     goose.ErrorFactory
}

func (decoder *doublePathResponseDecoder) DoublePath(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	if respErr, ok := decoder.errorDecoder(ctx, response, decoder.errorFactory); ok {
		return nil, respErr
	}
	resp := &httpbody.HttpBody{}
	if err := client.DecodeHttpBody(ctx, response, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

type StringPathService interface {
	StringPath(ctx context.Context, req *StringPathRequest) (*httpbody.HttpBody, error)
}

func AppendStringPathRoute(router *http.ServeMux, service StringPathService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := stringPathHandler{
		service: service,
		decoder: stringPathRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: stringPathResponseEncoder{
			marshalOptions:   options.MarshalOptions(),
			unmarshalOptions: options.UnmarshalOptions(),
		},
		errorEncoder:            options.ErrorEncoder(),
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              server.Chain(options.Middlewares()...),
	}
	router.Handle("GET /v1/{string}/{opt_string}/{wrap_string}/{multi_string...}", http.HandlerFunc(handler.StringPath))
	return router
}

type stringPathHandler struct {
	service                 StringPathService
	decoder                 stringPathRequestDecoder
	encoder                 stringPathResponseEncoder
	errorEncoder            goose.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              server.Middleware
}

func (h stringPathHandler) StringPath(response http.ResponseWriter, request *http.Request) {
	invoke := func(response http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		req, err := h.decoder.StringPath(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := goose.ValidateRequest(ctx, req, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		resp, err := h.service.StringPath(ctx, req)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := h.encoder.StringPath(ctx, response, resp); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
	}
	server.Invoke(h.middleware, response, request, invoke)
}

type stringPathRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder stringPathRequestDecoder) StringPath(ctx context.Context, request *http.Request) (*StringPathRequest, error) {
	req := &StringPathRequest{}
	ok, err := server.CustomDecodeRequest(ctx, request, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := goose.FormFromPath(request, "string", "opt_string", "wrap_string", "multi_string")
	var varErr error
	req.String_ = vars.Get("string")
	req.OptString = proto.String(vars.Get("opt_string"))
	req.WrapString = wrapperspb.String(vars.Get("wrap_string"))
	req.MultiString = vars.Get("multi_string")
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type stringPathResponseEncoder struct {
	marshalOptions   protojson.MarshalOptions
	unmarshalOptions protojson.UnmarshalOptions
}

func (encoder stringPathResponseEncoder) StringPath(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

func NewStringPathClient(target string, opts ...client.Option) StringPathService {
	options := client.NewOptions(opts...)
	client := &stringPathClient{
		client: options.Client(),
		encoder: stringPathRequestEncoder{
			target:         target,
			marshalOptions: options.MarshalOptions(),
			resolver:       options.Resolver(),
		},
		decoder: stringPathResponseDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
			errorDecoder:     options.ErrorDecoder(),
			errorFactory:     options.ErrorFactory(),
		},
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              client.Chain(options.Middlewares()...),
	}
	return client
}

type stringPathClient struct {
	client                  *http.Client
	encoder                 stringPathRequestEncoder
	decoder                 stringPathResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              client.Middleware
}

func (c *stringPathClient) StringPath(ctx context.Context, req *StringPathRequest) (*httpbody.HttpBody, error) {
	if err := goose.ValidateRequest(ctx, req, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	request, err := c.encoder.StringPath(ctx, req)
	if err != nil {
		return nil, err
	}
	response, err := client.Invoke(c.middleware, c.client, request)
	if err != nil {
		return nil, err
	}
	resp, err := c.decoder.StringPath(ctx, response)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type stringPathRequestEncoder struct {
	target         string
	marshalOptions protojson.MarshalOptions
	resolver       resolver.Resolver
}

func (encoder *stringPathRequestEncoder) StringPath(ctx context.Context, req *StringPathRequest) (*http.Request, error) {
	if req == nil {
		return nil, errors.New("request is nil")
	}
	target, err := resolver.Resolve(ctx, encoder.resolver, encoder.target)
	if err != nil {
		return nil, err
	}
	method := "GET"
	header := http.Header{}
	var body bytes.Buffer
	path := "/v1/{string}/{opt_string}/{wrap_string}/{multi_string...}"
	pairs := map[string]string{
		"string":       req.GetString_(),
		"opt_string":   req.GetOptString(),
		"wrap_string":  req.GetWrapString().GetValue(),
		"multi_string": req.GetMultiString(),
	}
	path = goose.URLPath(path, pairs)
	path, err = url.JoinPath(target.Path, path)
	if err != nil {
		return nil, err
	}
	target.Path = path
	request, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
	if err != nil {
		return nil, err
	}
	goose.CopyHeader(request.Header, header)
	return request, nil
}

type stringPathResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
	errorDecoder     goose.ErrorDecoder
	errorFactory     goose.ErrorFactory
}

func (decoder *stringPathResponseDecoder) StringPath(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	if respErr, ok := decoder.errorDecoder(ctx, response, decoder.errorFactory); ok {
		return nil, respErr
	}
	resp := &httpbody.HttpBody{}
	if err := client.DecodeHttpBody(ctx, response, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

type EnumPathService interface {
	EnumPath(ctx context.Context, req *EnumPathRequest) (*httpbody.HttpBody, error)
}

func AppendEnumPathRoute(router *http.ServeMux, service EnumPathService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := enumPathHandler{
		service: service,
		decoder: enumPathRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: enumPathResponseEncoder{
			marshalOptions:   options.MarshalOptions(),
			unmarshalOptions: options.UnmarshalOptions(),
		},
		errorEncoder:            options.ErrorEncoder(),
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              server.Chain(options.Middlewares()...),
	}
	router.Handle("GET /v1/{status}/{opt_status}", http.HandlerFunc(handler.EnumPath))
	return router
}

type enumPathHandler struct {
	service                 EnumPathService
	decoder                 enumPathRequestDecoder
	encoder                 enumPathResponseEncoder
	errorEncoder            goose.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              server.Middleware
}

func (h enumPathHandler) EnumPath(response http.ResponseWriter, request *http.Request) {
	invoke := func(response http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		req, err := h.decoder.EnumPath(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := goose.ValidateRequest(ctx, req, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		resp, err := h.service.EnumPath(ctx, req)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := h.encoder.EnumPath(ctx, response, resp); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
	}
	server.Invoke(h.middleware, response, request, invoke)
}

type enumPathRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder enumPathRequestDecoder) EnumPath(ctx context.Context, request *http.Request) (*EnumPathRequest, error) {
	req := &EnumPathRequest{}
	ok, err := server.CustomDecodeRequest(ctx, request, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	vars := goose.FormFromPath(request, "status", "opt_status")
	var varErr error
	req.Status, varErr = goose.GetForm[EnumPathRequest_Status](varErr, vars, "status", goose.GetInt[EnumPathRequest_Status])
	req.OptStatus, varErr = goose.GetForm[*EnumPathRequest_Status](varErr, vars, "opt_status", goose.GetIntPtr[EnumPathRequest_Status])
	if varErr != nil {
		return nil, varErr
	}
	return req, nil
}

type enumPathResponseEncoder struct {
	marshalOptions   protojson.MarshalOptions
	unmarshalOptions protojson.UnmarshalOptions
}

func (encoder enumPathResponseEncoder) EnumPath(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

func NewEnumPathClient(target string, opts ...client.Option) EnumPathService {
	options := client.NewOptions(opts...)
	client := &enumPathClient{
		client: options.Client(),
		encoder: enumPathRequestEncoder{
			target:         target,
			marshalOptions: options.MarshalOptions(),
			resolver:       options.Resolver(),
		},
		decoder: enumPathResponseDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
			errorDecoder:     options.ErrorDecoder(),
			errorFactory:     options.ErrorFactory(),
		},
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              client.Chain(options.Middlewares()...),
	}
	return client
}

type enumPathClient struct {
	client                  *http.Client
	encoder                 enumPathRequestEncoder
	decoder                 enumPathResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              client.Middleware
}

func (c *enumPathClient) EnumPath(ctx context.Context, req *EnumPathRequest) (*httpbody.HttpBody, error) {
	if err := goose.ValidateRequest(ctx, req, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	request, err := c.encoder.EnumPath(ctx, req)
	if err != nil {
		return nil, err
	}
	response, err := client.Invoke(c.middleware, c.client, request)
	if err != nil {
		return nil, err
	}
	resp, err := c.decoder.EnumPath(ctx, response)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type enumPathRequestEncoder struct {
	target         string
	marshalOptions protojson.MarshalOptions
	resolver       resolver.Resolver
}

func (encoder *enumPathRequestEncoder) EnumPath(ctx context.Context, req *EnumPathRequest) (*http.Request, error) {
	if req == nil {
		return nil, errors.New("request is nil")
	}
	target, err := resolver.Resolve(ctx, encoder.resolver, encoder.target)
	if err != nil {
		return nil, err
	}
	method := "GET"
	header := http.Header{}
	var body bytes.Buffer
	path := "/v1/{status}/{opt_status}"
	pairs := map[string]string{
		"status":     goose.FormatInt(req.GetStatus(), 10),
		"opt_status": goose.FormatInt(req.GetOptStatus(), 10),
	}
	path = goose.URLPath(path, pairs)
	path, err = url.JoinPath(target.Path, path)
	if err != nil {
		return nil, err
	}
	target.Path = path
	request, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
	if err != nil {
		return nil, err
	}
	goose.CopyHeader(request.Header, header)
	return request, nil
}

type enumPathResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
	errorDecoder     goose.ErrorDecoder
	errorFactory     goose.ErrorFactory
}

func (decoder *enumPathResponseDecoder) EnumPath(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	if respErr, ok := decoder.errorDecoder(ctx, response, decoder.errorFactory); ok {
		return nil, respErr
	}
	resp := &httpbody.HttpBody{}
	if err := client.DecodeHttpBody(ctx, response, resp); err != nil {
		return nil, err
	}
	return resp, nil
}
