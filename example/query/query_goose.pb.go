// Code generated by protoc-gen-goose. DO NOT EDIT.

package query

import (
	bytes "bytes"
	context "context"
	errors "errors"
	goose "github.com/soyacen/goose"
	client "github.com/soyacen/goose/client"
	resolver "github.com/soyacen/goose/client/resolver"
	server "github.com/soyacen/goose/server"
	httpbody "google.golang.org/genproto/googleapis/api/httpbody"
	protojson "google.golang.org/protobuf/encoding/protojson"
	proto "google.golang.org/protobuf/proto"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	http "net/http"
	url "net/url"
)

type BoolQueryService interface {
	BoolQuery(ctx context.Context, req *BoolQueryRequest) (*httpbody.HttpBody, error)
}

func AppendBoolQueryHttpRoute(router *http.ServeMux, service BoolQueryService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := boolQueryHandler{
		service: service,
		decoder: boolQueryRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: boolQueryResponseEncoder{
			marshalOptions:   options.MarshalOptions(),
			unmarshalOptions: options.UnmarshalOptions(),
		},
		errorEncoder:            options.ErrorEncoder(),
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              server.Chain(options.Middlewares()...),
	}
	router.Handle("GET /v1/bool", http.HandlerFunc(handler.BoolQuery))
	return router
}

type boolQueryHandler struct {
	service                 BoolQueryService
	decoder                 boolQueryRequestDecoder
	encoder                 boolQueryResponseEncoder
	errorEncoder            goose.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              server.Middleware
}

func (h boolQueryHandler) BoolQuery(response http.ResponseWriter, request *http.Request) {
	invoke := func(response http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		req, err := h.decoder.BoolQuery(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := goose.ValidateRequest(ctx, req, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		resp, err := h.service.BoolQuery(ctx, req)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := h.encoder.BoolQuery(ctx, response, resp); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
	}
	server.Invoke(h.middleware, response, request, invoke, _leo_goose_example_query_v1_BoolQuery_BoolQuery_Desc.RouteInfo)
}

type boolQueryRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder boolQueryRequestDecoder) BoolQuery(ctx context.Context, request *http.Request) (*BoolQueryRequest, error) {
	req := &BoolQueryRequest{}
	ok, err := server.CustomDecodeRequest(ctx, request, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := request.URL.Query()
	var queryErr error
	req.Bool, queryErr = goose.GetForm[bool](queryErr, queries, "bool", goose.GetBool)
	req.OptBool, queryErr = goose.GetForm[*bool](queryErr, queries, "opt_bool", goose.GetBoolPtr)
	req.WrapBool, queryErr = goose.GetForm[*wrapperspb.BoolValue](queryErr, queries, "wrap_bool", goose.GetBoolValue)
	req.ListBool, queryErr = goose.GetForm[[]bool](queryErr, queries, "list_bool", goose.GetBoolSlice)
	req.ListWrapBool, queryErr = goose.GetForm[[]*wrapperspb.BoolValue](queryErr, queries, "list_wrap_bool", goose.GetBoolValueSlice)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type boolQueryResponseEncoder struct {
	marshalOptions   protojson.MarshalOptions
	unmarshalOptions protojson.UnmarshalOptions
}

func (encoder boolQueryResponseEncoder) BoolQuery(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

func NewBoolQueryHttpClient(target string, opts ...client.Option) BoolQueryService {
	options := client.NewOptions(opts...)
	client := &boolQueryHttpClient{
		client: options.Client(),
		encoder: boolQueryRequestEncoder{
			target:         target,
			marshalOptions: options.MarshalOptions(),
			resolver:       options.Resolver(),
		},
		decoder: boolQueryResponseDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
			errorDecoder:     options.ErrorDecoder(),
			errorFactory:     options.ErrorFactory(),
		},
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              client.Chain(options.Middlewares()...),
	}
	return client
}

type boolQueryHttpClient struct {
	client                  *http.Client
	encoder                 boolQueryRequestEncoder
	decoder                 boolQueryResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              client.Middleware
}

func (c *boolQueryHttpClient) BoolQuery(ctx context.Context, req *BoolQueryRequest) (*httpbody.HttpBody, error) {
	if err := goose.ValidateRequest(ctx, req, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	request, err := c.encoder.BoolQuery(ctx, req)
	if err != nil {
		return nil, err
	}
	response, err := client.Invoke(c.middleware, c.client, request, _leo_goose_example_query_v1_BoolQuery_BoolQuery_Desc.RouteInfo)
	if err != nil {
		return nil, err
	}
	resp, err := c.decoder.BoolQuery(ctx, response)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type boolQueryRequestEncoder struct {
	target         string
	marshalOptions protojson.MarshalOptions
	resolver       resolver.Resolver
}

func (encoder *boolQueryRequestEncoder) BoolQuery(ctx context.Context, req *BoolQueryRequest) (*http.Request, error) {
	if req == nil {
		return nil, errors.New("request is nil")
	}
	target, err := resolver.Resolve(ctx, encoder.resolver, encoder.target)
	if err != nil {
		return nil, err
	}
	method := "GET"
	header := http.Header{}
	var body bytes.Buffer
	path := "/v1/bool"
	target.Path = path
	queries := url.Values{}
	queries["bool"] = append(queries["bool"], goose.FormatBool(req.GetBool()))
	queries["opt_bool"] = append(queries["opt_bool"], goose.FormatBool(req.GetOptBool()))
	queries["wrap_bool"] = append(queries["wrap_bool"], goose.FormatBool(req.GetWrapBool().GetValue()))
	queries["list_bool"] = append(queries["list_bool"], goose.FormatBoolSlice(req.GetListBool())...)
	queries["list_wrap_bool"] = append(queries["list_wrap_bool"], goose.FormatBoolSlice(goose.UnwrapBoolSlice(req.GetListWrapBool()))...)
	target.RawQuery = queries.Encode()
	request, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
	if err != nil {
		return nil, err
	}
	goose.CopyHeader(request.Header, header)
	return request, nil
}

type boolQueryResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
	errorDecoder     goose.ErrorDecoder
	errorFactory     goose.ErrorFactory
}

func (decoder *boolQueryResponseDecoder) BoolQuery(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	if respErr, ok := decoder.errorDecoder(ctx, response, decoder.errorFactory); ok {
		return nil, respErr
	}
	resp := &httpbody.HttpBody{}
	if err := client.DecodeHttpBody(ctx, response, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

var _leo_goose_example_query_v1_BoolQuery_BoolQuery_Desc = &goose.Desc{
	RouteInfo: &goose.RouteInfo{
		HttpMethod: "GET",
		Pattern:    "/v1/bool",
		FullMethod: "/leo.goose.example.query.v1.BoolQuery/BoolQuery",
	},
}

type Int32QueryService interface {
	Int32Query(ctx context.Context, req *Int32QueryRequest) (*httpbody.HttpBody, error)
}

func AppendInt32QueryHttpRoute(router *http.ServeMux, service Int32QueryService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := int32QueryHandler{
		service: service,
		decoder: int32QueryRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: int32QueryResponseEncoder{
			marshalOptions:   options.MarshalOptions(),
			unmarshalOptions: options.UnmarshalOptions(),
		},
		errorEncoder:            options.ErrorEncoder(),
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              server.Chain(options.Middlewares()...),
	}
	router.Handle("GET /v1/int32", http.HandlerFunc(handler.Int32Query))
	return router
}

type int32QueryHandler struct {
	service                 Int32QueryService
	decoder                 int32QueryRequestDecoder
	encoder                 int32QueryResponseEncoder
	errorEncoder            goose.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              server.Middleware
}

func (h int32QueryHandler) Int32Query(response http.ResponseWriter, request *http.Request) {
	invoke := func(response http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		req, err := h.decoder.Int32Query(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := goose.ValidateRequest(ctx, req, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		resp, err := h.service.Int32Query(ctx, req)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := h.encoder.Int32Query(ctx, response, resp); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
	}
	server.Invoke(h.middleware, response, request, invoke, _leo_goose_example_query_v1_Int32Query_Int32Query_Desc.RouteInfo)
}

type int32QueryRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int32QueryRequestDecoder) Int32Query(ctx context.Context, request *http.Request) (*Int32QueryRequest, error) {
	req := &Int32QueryRequest{}
	ok, err := server.CustomDecodeRequest(ctx, request, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := request.URL.Query()
	var queryErr error
	req.Int32, queryErr = goose.GetForm[int32](queryErr, queries, "int32", goose.GetInt)
	req.Sint32, queryErr = goose.GetForm[int32](queryErr, queries, "sint32", goose.GetInt)
	req.Sfixed32, queryErr = goose.GetForm[int32](queryErr, queries, "sfixed32", goose.GetInt)
	req.OptInt32, queryErr = goose.GetForm[*int32](queryErr, queries, "opt_int32", goose.GetIntPtr)
	req.OptSint32, queryErr = goose.GetForm[*int32](queryErr, queries, "opt_sint32", goose.GetIntPtr)
	req.OptSfixed32, queryErr = goose.GetForm[*int32](queryErr, queries, "opt_sfixed32", goose.GetIntPtr)
	req.WrapInt32, queryErr = goose.GetForm[*wrapperspb.Int32Value](queryErr, queries, "wrap_int32", goose.GetInt32Value)
	req.ListInt32, queryErr = goose.GetForm[[]int32](queryErr, queries, "list_int32", goose.GetIntSlice)
	req.ListSint32, queryErr = goose.GetForm[[]int32](queryErr, queries, "list_sint32", goose.GetIntSlice)
	req.ListSfixed32, queryErr = goose.GetForm[[]int32](queryErr, queries, "list_sfixed32", goose.GetIntSlice)
	req.ListWrapInt32, queryErr = goose.GetForm[[]*wrapperspb.Int32Value](queryErr, queries, "list_wrap_int32", goose.GetInt32ValueSlice)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type int32QueryResponseEncoder struct {
	marshalOptions   protojson.MarshalOptions
	unmarshalOptions protojson.UnmarshalOptions
}

func (encoder int32QueryResponseEncoder) Int32Query(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

func NewInt32QueryHttpClient(target string, opts ...client.Option) Int32QueryService {
	options := client.NewOptions(opts...)
	client := &int32QueryHttpClient{
		client: options.Client(),
		encoder: int32QueryRequestEncoder{
			target:         target,
			marshalOptions: options.MarshalOptions(),
			resolver:       options.Resolver(),
		},
		decoder: int32QueryResponseDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
			errorDecoder:     options.ErrorDecoder(),
			errorFactory:     options.ErrorFactory(),
		},
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              client.Chain(options.Middlewares()...),
	}
	return client
}

type int32QueryHttpClient struct {
	client                  *http.Client
	encoder                 int32QueryRequestEncoder
	decoder                 int32QueryResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              client.Middleware
}

func (c *int32QueryHttpClient) Int32Query(ctx context.Context, req *Int32QueryRequest) (*httpbody.HttpBody, error) {
	if err := goose.ValidateRequest(ctx, req, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	request, err := c.encoder.Int32Query(ctx, req)
	if err != nil {
		return nil, err
	}
	response, err := client.Invoke(c.middleware, c.client, request, _leo_goose_example_query_v1_Int32Query_Int32Query_Desc.RouteInfo)
	if err != nil {
		return nil, err
	}
	resp, err := c.decoder.Int32Query(ctx, response)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type int32QueryRequestEncoder struct {
	target         string
	marshalOptions protojson.MarshalOptions
	resolver       resolver.Resolver
}

func (encoder *int32QueryRequestEncoder) Int32Query(ctx context.Context, req *Int32QueryRequest) (*http.Request, error) {
	if req == nil {
		return nil, errors.New("request is nil")
	}
	target, err := resolver.Resolve(ctx, encoder.resolver, encoder.target)
	if err != nil {
		return nil, err
	}
	method := "GET"
	header := http.Header{}
	var body bytes.Buffer
	path := "/v1/int32"
	target.Path = path
	queries := url.Values{}
	queries["int32"] = append(queries["int32"], goose.FormatInt(req.GetInt32(), 10))
	queries["sint32"] = append(queries["sint32"], goose.FormatInt(req.GetSint32(), 10))
	queries["sfixed32"] = append(queries["sfixed32"], goose.FormatInt(req.GetSfixed32(), 10))
	queries["opt_int32"] = append(queries["opt_int32"], goose.FormatInt(req.GetOptInt32(), 10))
	queries["opt_sint32"] = append(queries["opt_sint32"], goose.FormatInt(req.GetOptSint32(), 10))
	queries["opt_sfixed32"] = append(queries["opt_sfixed32"], goose.FormatInt(req.GetOptSfixed32(), 10))
	queries["wrap_int32"] = append(queries["wrap_int32"], goose.FormatInt(req.GetWrapInt32().GetValue(), 10))
	queries["list_int32"] = append(queries["list_int32"], goose.FormatIntSlice(req.GetListInt32(), 10)...)
	queries["list_sint32"] = append(queries["list_sint32"], goose.FormatIntSlice(req.GetListSint32(), 10)...)
	queries["list_sfixed32"] = append(queries["list_sfixed32"], goose.FormatIntSlice(req.GetListSfixed32(), 10)...)
	queries["list_wrap_int32"] = append(queries["list_wrap_int32"], goose.FormatIntSlice(goose.UnwrapInt32Slice(req.GetListWrapInt32()), 10)...)
	target.RawQuery = queries.Encode()
	request, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
	if err != nil {
		return nil, err
	}
	goose.CopyHeader(request.Header, header)
	return request, nil
}

type int32QueryResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
	errorDecoder     goose.ErrorDecoder
	errorFactory     goose.ErrorFactory
}

func (decoder *int32QueryResponseDecoder) Int32Query(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	if respErr, ok := decoder.errorDecoder(ctx, response, decoder.errorFactory); ok {
		return nil, respErr
	}
	resp := &httpbody.HttpBody{}
	if err := client.DecodeHttpBody(ctx, response, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

var _leo_goose_example_query_v1_Int32Query_Int32Query_Desc = &goose.Desc{
	RouteInfo: &goose.RouteInfo{
		HttpMethod: "GET",
		Pattern:    "/v1/int32",
		FullMethod: "/leo.goose.example.query.v1.Int32Query/Int32Query",
	},
}

type Int64QueryService interface {
	Int64Query(ctx context.Context, req *Int64QueryRequest) (*httpbody.HttpBody, error)
}

func AppendInt64QueryHttpRoute(router *http.ServeMux, service Int64QueryService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := int64QueryHandler{
		service: service,
		decoder: int64QueryRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: int64QueryResponseEncoder{
			marshalOptions:   options.MarshalOptions(),
			unmarshalOptions: options.UnmarshalOptions(),
		},
		errorEncoder:            options.ErrorEncoder(),
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              server.Chain(options.Middlewares()...),
	}
	router.Handle("GET /v1/int64", http.HandlerFunc(handler.Int64Query))
	return router
}

type int64QueryHandler struct {
	service                 Int64QueryService
	decoder                 int64QueryRequestDecoder
	encoder                 int64QueryResponseEncoder
	errorEncoder            goose.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              server.Middleware
}

func (h int64QueryHandler) Int64Query(response http.ResponseWriter, request *http.Request) {
	invoke := func(response http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		req, err := h.decoder.Int64Query(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := goose.ValidateRequest(ctx, req, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		resp, err := h.service.Int64Query(ctx, req)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := h.encoder.Int64Query(ctx, response, resp); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
	}
	server.Invoke(h.middleware, response, request, invoke, _leo_goose_example_query_v1_Int64Query_Int64Query_Desc.RouteInfo)
}

type int64QueryRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int64QueryRequestDecoder) Int64Query(ctx context.Context, request *http.Request) (*Int64QueryRequest, error) {
	req := &Int64QueryRequest{}
	ok, err := server.CustomDecodeRequest(ctx, request, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := request.URL.Query()
	var queryErr error
	req.Int64, queryErr = goose.GetForm[int64](queryErr, queries, "int64", goose.GetInt)
	req.Sint64, queryErr = goose.GetForm[int64](queryErr, queries, "sint64", goose.GetInt)
	req.Sfixed64, queryErr = goose.GetForm[int64](queryErr, queries, "sfixed64", goose.GetInt)
	req.OptInt64, queryErr = goose.GetForm[*int64](queryErr, queries, "opt_int64", goose.GetIntPtr)
	req.OptSint64, queryErr = goose.GetForm[*int64](queryErr, queries, "opt_sint64", goose.GetIntPtr)
	req.OptSfixed64, queryErr = goose.GetForm[*int64](queryErr, queries, "opt_sfixed64", goose.GetIntPtr)
	req.WrapInt64, queryErr = goose.GetForm[*wrapperspb.Int64Value](queryErr, queries, "wrap_int64", goose.GetInt64Value)
	req.ListInt64, queryErr = goose.GetForm[[]int64](queryErr, queries, "list_int64", goose.GetIntSlice)
	req.ListSint64, queryErr = goose.GetForm[[]int64](queryErr, queries, "list_sint64", goose.GetIntSlice)
	req.ListSfixed64, queryErr = goose.GetForm[[]int64](queryErr, queries, "list_sfixed64", goose.GetIntSlice)
	req.ListWrapInt64, queryErr = goose.GetForm[[]*wrapperspb.Int64Value](queryErr, queries, "list_wrap_int64", goose.GetInt64ValueSlice)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type int64QueryResponseEncoder struct {
	marshalOptions   protojson.MarshalOptions
	unmarshalOptions protojson.UnmarshalOptions
}

func (encoder int64QueryResponseEncoder) Int64Query(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

func NewInt64QueryHttpClient(target string, opts ...client.Option) Int64QueryService {
	options := client.NewOptions(opts...)
	client := &int64QueryHttpClient{
		client: options.Client(),
		encoder: int64QueryRequestEncoder{
			target:         target,
			marshalOptions: options.MarshalOptions(),
			resolver:       options.Resolver(),
		},
		decoder: int64QueryResponseDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
			errorDecoder:     options.ErrorDecoder(),
			errorFactory:     options.ErrorFactory(),
		},
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              client.Chain(options.Middlewares()...),
	}
	return client
}

type int64QueryHttpClient struct {
	client                  *http.Client
	encoder                 int64QueryRequestEncoder
	decoder                 int64QueryResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              client.Middleware
}

func (c *int64QueryHttpClient) Int64Query(ctx context.Context, req *Int64QueryRequest) (*httpbody.HttpBody, error) {
	if err := goose.ValidateRequest(ctx, req, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	request, err := c.encoder.Int64Query(ctx, req)
	if err != nil {
		return nil, err
	}
	response, err := client.Invoke(c.middleware, c.client, request, _leo_goose_example_query_v1_Int64Query_Int64Query_Desc.RouteInfo)
	if err != nil {
		return nil, err
	}
	resp, err := c.decoder.Int64Query(ctx, response)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type int64QueryRequestEncoder struct {
	target         string
	marshalOptions protojson.MarshalOptions
	resolver       resolver.Resolver
}

func (encoder *int64QueryRequestEncoder) Int64Query(ctx context.Context, req *Int64QueryRequest) (*http.Request, error) {
	if req == nil {
		return nil, errors.New("request is nil")
	}
	target, err := resolver.Resolve(ctx, encoder.resolver, encoder.target)
	if err != nil {
		return nil, err
	}
	method := "GET"
	header := http.Header{}
	var body bytes.Buffer
	path := "/v1/int64"
	target.Path = path
	queries := url.Values{}
	queries["int64"] = append(queries["int64"], goose.FormatInt(req.GetInt64(), 10))
	queries["sint64"] = append(queries["sint64"], goose.FormatInt(req.GetSint64(), 10))
	queries["sfixed64"] = append(queries["sfixed64"], goose.FormatInt(req.GetSfixed64(), 10))
	queries["opt_int64"] = append(queries["opt_int64"], goose.FormatInt(req.GetOptInt64(), 10))
	queries["opt_sint64"] = append(queries["opt_sint64"], goose.FormatInt(req.GetOptSint64(), 10))
	queries["opt_sfixed64"] = append(queries["opt_sfixed64"], goose.FormatInt(req.GetOptSfixed64(), 10))
	queries["wrap_int64"] = append(queries["wrap_int64"], goose.FormatInt(req.GetWrapInt64().GetValue(), 10))
	queries["list_int64"] = append(queries["list_int64"], goose.FormatIntSlice(req.GetListInt64(), 10)...)
	queries["list_sint64"] = append(queries["list_sint64"], goose.FormatIntSlice(req.GetListSint64(), 10)...)
	queries["list_sfixed64"] = append(queries["list_sfixed64"], goose.FormatIntSlice(req.GetListSfixed64(), 10)...)
	queries["list_wrap_int64"] = append(queries["list_wrap_int64"], goose.FormatIntSlice(goose.UnwrapInt64Slice(req.GetListWrapInt64()), 10)...)
	target.RawQuery = queries.Encode()
	request, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
	if err != nil {
		return nil, err
	}
	goose.CopyHeader(request.Header, header)
	return request, nil
}

type int64QueryResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
	errorDecoder     goose.ErrorDecoder
	errorFactory     goose.ErrorFactory
}

func (decoder *int64QueryResponseDecoder) Int64Query(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	if respErr, ok := decoder.errorDecoder(ctx, response, decoder.errorFactory); ok {
		return nil, respErr
	}
	resp := &httpbody.HttpBody{}
	if err := client.DecodeHttpBody(ctx, response, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

var _leo_goose_example_query_v1_Int64Query_Int64Query_Desc = &goose.Desc{
	RouteInfo: &goose.RouteInfo{
		HttpMethod: "GET",
		Pattern:    "/v1/int64",
		FullMethod: "/leo.goose.example.query.v1.Int64Query/Int64Query",
	},
}

type Uint32QueryService interface {
	Uint32Query(ctx context.Context, req *Uint32QueryRequest) (*httpbody.HttpBody, error)
}

func AppendUint32QueryHttpRoute(router *http.ServeMux, service Uint32QueryService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := uint32QueryHandler{
		service: service,
		decoder: uint32QueryRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: uint32QueryResponseEncoder{
			marshalOptions:   options.MarshalOptions(),
			unmarshalOptions: options.UnmarshalOptions(),
		},
		errorEncoder:            options.ErrorEncoder(),
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              server.Chain(options.Middlewares()...),
	}
	router.Handle("GET /v1/uint32", http.HandlerFunc(handler.Uint32Query))
	return router
}

type uint32QueryHandler struct {
	service                 Uint32QueryService
	decoder                 uint32QueryRequestDecoder
	encoder                 uint32QueryResponseEncoder
	errorEncoder            goose.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              server.Middleware
}

func (h uint32QueryHandler) Uint32Query(response http.ResponseWriter, request *http.Request) {
	invoke := func(response http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		req, err := h.decoder.Uint32Query(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := goose.ValidateRequest(ctx, req, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		resp, err := h.service.Uint32Query(ctx, req)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := h.encoder.Uint32Query(ctx, response, resp); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
	}
	server.Invoke(h.middleware, response, request, invoke, _leo_goose_example_query_v1_Uint32Query_Uint32Query_Desc.RouteInfo)
}

type uint32QueryRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint32QueryRequestDecoder) Uint32Query(ctx context.Context, request *http.Request) (*Uint32QueryRequest, error) {
	req := &Uint32QueryRequest{}
	ok, err := server.CustomDecodeRequest(ctx, request, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := request.URL.Query()
	var queryErr error
	req.Uint32, queryErr = goose.GetForm[uint32](queryErr, queries, "uint32", goose.GetUint)
	req.Fixed32, queryErr = goose.GetForm[uint32](queryErr, queries, "fixed32", goose.GetUint)
	req.OptUint32, queryErr = goose.GetForm[*uint32](queryErr, queries, "opt_uint32", goose.GetUintPtr)
	req.OptFixed32, queryErr = goose.GetForm[*uint32](queryErr, queries, "opt_fixed32", goose.GetUintPtr)
	req.WrapUint32, queryErr = goose.GetForm[*wrapperspb.UInt32Value](queryErr, queries, "wrap_uint32", goose.GetUint32Value)
	req.ListUint32, queryErr = goose.GetForm[[]uint32](queryErr, queries, "list_uint32", goose.GetUintSlice)
	req.ListFixed32, queryErr = goose.GetForm[[]uint32](queryErr, queries, "list_fixed32", goose.GetUintSlice)
	req.ListWrapUint32, queryErr = goose.GetForm[[]*wrapperspb.UInt32Value](queryErr, queries, "list_wrap_uint32", goose.GetUint32ValueSlice)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type uint32QueryResponseEncoder struct {
	marshalOptions   protojson.MarshalOptions
	unmarshalOptions protojson.UnmarshalOptions
}

func (encoder uint32QueryResponseEncoder) Uint32Query(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

func NewUint32QueryHttpClient(target string, opts ...client.Option) Uint32QueryService {
	options := client.NewOptions(opts...)
	client := &uint32QueryHttpClient{
		client: options.Client(),
		encoder: uint32QueryRequestEncoder{
			target:         target,
			marshalOptions: options.MarshalOptions(),
			resolver:       options.Resolver(),
		},
		decoder: uint32QueryResponseDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
			errorDecoder:     options.ErrorDecoder(),
			errorFactory:     options.ErrorFactory(),
		},
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              client.Chain(options.Middlewares()...),
	}
	return client
}

type uint32QueryHttpClient struct {
	client                  *http.Client
	encoder                 uint32QueryRequestEncoder
	decoder                 uint32QueryResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              client.Middleware
}

func (c *uint32QueryHttpClient) Uint32Query(ctx context.Context, req *Uint32QueryRequest) (*httpbody.HttpBody, error) {
	if err := goose.ValidateRequest(ctx, req, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	request, err := c.encoder.Uint32Query(ctx, req)
	if err != nil {
		return nil, err
	}
	response, err := client.Invoke(c.middleware, c.client, request, _leo_goose_example_query_v1_Uint32Query_Uint32Query_Desc.RouteInfo)
	if err != nil {
		return nil, err
	}
	resp, err := c.decoder.Uint32Query(ctx, response)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type uint32QueryRequestEncoder struct {
	target         string
	marshalOptions protojson.MarshalOptions
	resolver       resolver.Resolver
}

func (encoder *uint32QueryRequestEncoder) Uint32Query(ctx context.Context, req *Uint32QueryRequest) (*http.Request, error) {
	if req == nil {
		return nil, errors.New("request is nil")
	}
	target, err := resolver.Resolve(ctx, encoder.resolver, encoder.target)
	if err != nil {
		return nil, err
	}
	method := "GET"
	header := http.Header{}
	var body bytes.Buffer
	path := "/v1/uint32"
	target.Path = path
	queries := url.Values{}
	queries["uint32"] = append(queries["uint32"], goose.FormatUint(req.GetUint32(), 10))
	queries["fixed32"] = append(queries["fixed32"], goose.FormatUint(req.GetFixed32(), 10))
	queries["opt_uint32"] = append(queries["opt_uint32"], goose.FormatUint(req.GetOptUint32(), 10))
	queries["opt_fixed32"] = append(queries["opt_fixed32"], goose.FormatUint(req.GetOptFixed32(), 10))
	queries["wrap_uint32"] = append(queries["wrap_uint32"], goose.FormatUint(req.GetWrapUint32().GetValue(), 10))
	queries["list_uint32"] = append(queries["list_uint32"], goose.FormatUintSlice(req.GetListUint32(), 10)...)
	queries["list_fixed32"] = append(queries["list_fixed32"], goose.FormatUintSlice(req.GetListFixed32(), 10)...)
	queries["list_wrap_uint32"] = append(queries["list_wrap_uint32"], goose.FormatUintSlice(goose.UnwrapUint32Slice(req.GetListWrapUint32()), 10)...)
	target.RawQuery = queries.Encode()
	request, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
	if err != nil {
		return nil, err
	}
	goose.CopyHeader(request.Header, header)
	return request, nil
}

type uint32QueryResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
	errorDecoder     goose.ErrorDecoder
	errorFactory     goose.ErrorFactory
}

func (decoder *uint32QueryResponseDecoder) Uint32Query(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	if respErr, ok := decoder.errorDecoder(ctx, response, decoder.errorFactory); ok {
		return nil, respErr
	}
	resp := &httpbody.HttpBody{}
	if err := client.DecodeHttpBody(ctx, response, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

var _leo_goose_example_query_v1_Uint32Query_Uint32Query_Desc = &goose.Desc{
	RouteInfo: &goose.RouteInfo{
		HttpMethod: "GET",
		Pattern:    "/v1/uint32",
		FullMethod: "/leo.goose.example.query.v1.Uint32Query/Uint32Query",
	},
}

type Uint64QueryService interface {
	Uint64Query(ctx context.Context, req *Uint64QueryRequest) (*httpbody.HttpBody, error)
}

func AppendUint64QueryHttpRoute(router *http.ServeMux, service Uint64QueryService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := uint64QueryHandler{
		service: service,
		decoder: uint64QueryRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: uint64QueryResponseEncoder{
			marshalOptions:   options.MarshalOptions(),
			unmarshalOptions: options.UnmarshalOptions(),
		},
		errorEncoder:            options.ErrorEncoder(),
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              server.Chain(options.Middlewares()...),
	}
	router.Handle("GET /v1/uint64", http.HandlerFunc(handler.Uint64Query))
	return router
}

type uint64QueryHandler struct {
	service                 Uint64QueryService
	decoder                 uint64QueryRequestDecoder
	encoder                 uint64QueryResponseEncoder
	errorEncoder            goose.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              server.Middleware
}

func (h uint64QueryHandler) Uint64Query(response http.ResponseWriter, request *http.Request) {
	invoke := func(response http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		req, err := h.decoder.Uint64Query(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := goose.ValidateRequest(ctx, req, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		resp, err := h.service.Uint64Query(ctx, req)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := h.encoder.Uint64Query(ctx, response, resp); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
	}
	server.Invoke(h.middleware, response, request, invoke, _leo_goose_example_query_v1_Uint64Query_Uint64Query_Desc.RouteInfo)
}

type uint64QueryRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint64QueryRequestDecoder) Uint64Query(ctx context.Context, request *http.Request) (*Uint64QueryRequest, error) {
	req := &Uint64QueryRequest{}
	ok, err := server.CustomDecodeRequest(ctx, request, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := request.URL.Query()
	var queryErr error
	req.Uint64, queryErr = goose.GetForm[uint64](queryErr, queries, "uint64", goose.GetUint)
	req.Fixed64, queryErr = goose.GetForm[uint64](queryErr, queries, "fixed64", goose.GetUint)
	req.OptUint64, queryErr = goose.GetForm[*uint64](queryErr, queries, "opt_uint64", goose.GetUintPtr)
	req.OptFixed64, queryErr = goose.GetForm[*uint64](queryErr, queries, "opt_fixed64", goose.GetUintPtr)
	req.WrapUint64, queryErr = goose.GetForm[*wrapperspb.UInt64Value](queryErr, queries, "wrap_uint64", goose.GetUint64Value)
	req.ListUint64, queryErr = goose.GetForm[[]uint64](queryErr, queries, "list_uint64", goose.GetUintSlice)
	req.ListFixed64, queryErr = goose.GetForm[[]uint64](queryErr, queries, "list_fixed64", goose.GetUintSlice)
	req.ListWrapUint64, queryErr = goose.GetForm[[]*wrapperspb.UInt64Value](queryErr, queries, "list_wrap_uint64", goose.GetUint64ValueSlice)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type uint64QueryResponseEncoder struct {
	marshalOptions   protojson.MarshalOptions
	unmarshalOptions protojson.UnmarshalOptions
}

func (encoder uint64QueryResponseEncoder) Uint64Query(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

func NewUint64QueryHttpClient(target string, opts ...client.Option) Uint64QueryService {
	options := client.NewOptions(opts...)
	client := &uint64QueryHttpClient{
		client: options.Client(),
		encoder: uint64QueryRequestEncoder{
			target:         target,
			marshalOptions: options.MarshalOptions(),
			resolver:       options.Resolver(),
		},
		decoder: uint64QueryResponseDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
			errorDecoder:     options.ErrorDecoder(),
			errorFactory:     options.ErrorFactory(),
		},
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              client.Chain(options.Middlewares()...),
	}
	return client
}

type uint64QueryHttpClient struct {
	client                  *http.Client
	encoder                 uint64QueryRequestEncoder
	decoder                 uint64QueryResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              client.Middleware
}

func (c *uint64QueryHttpClient) Uint64Query(ctx context.Context, req *Uint64QueryRequest) (*httpbody.HttpBody, error) {
	if err := goose.ValidateRequest(ctx, req, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	request, err := c.encoder.Uint64Query(ctx, req)
	if err != nil {
		return nil, err
	}
	response, err := client.Invoke(c.middleware, c.client, request, _leo_goose_example_query_v1_Uint64Query_Uint64Query_Desc.RouteInfo)
	if err != nil {
		return nil, err
	}
	resp, err := c.decoder.Uint64Query(ctx, response)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type uint64QueryRequestEncoder struct {
	target         string
	marshalOptions protojson.MarshalOptions
	resolver       resolver.Resolver
}

func (encoder *uint64QueryRequestEncoder) Uint64Query(ctx context.Context, req *Uint64QueryRequest) (*http.Request, error) {
	if req == nil {
		return nil, errors.New("request is nil")
	}
	target, err := resolver.Resolve(ctx, encoder.resolver, encoder.target)
	if err != nil {
		return nil, err
	}
	method := "GET"
	header := http.Header{}
	var body bytes.Buffer
	path := "/v1/uint64"
	target.Path = path
	queries := url.Values{}
	queries["uint64"] = append(queries["uint64"], goose.FormatUint(req.GetUint64(), 10))
	queries["fixed64"] = append(queries["fixed64"], goose.FormatUint(req.GetFixed64(), 10))
	queries["opt_uint64"] = append(queries["opt_uint64"], goose.FormatUint(req.GetOptUint64(), 10))
	queries["opt_fixed64"] = append(queries["opt_fixed64"], goose.FormatUint(req.GetOptFixed64(), 10))
	queries["wrap_uint64"] = append(queries["wrap_uint64"], goose.FormatUint(req.GetWrapUint64().GetValue(), 10))
	queries["list_uint64"] = append(queries["list_uint64"], goose.FormatUintSlice(req.GetListUint64(), 10)...)
	queries["list_fixed64"] = append(queries["list_fixed64"], goose.FormatUintSlice(req.GetListFixed64(), 10)...)
	queries["list_wrap_uint64"] = append(queries["list_wrap_uint64"], goose.FormatUintSlice(goose.UnwrapUint64Slice(req.GetListWrapUint64()), 10)...)
	target.RawQuery = queries.Encode()
	request, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
	if err != nil {
		return nil, err
	}
	goose.CopyHeader(request.Header, header)
	return request, nil
}

type uint64QueryResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
	errorDecoder     goose.ErrorDecoder
	errorFactory     goose.ErrorFactory
}

func (decoder *uint64QueryResponseDecoder) Uint64Query(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	if respErr, ok := decoder.errorDecoder(ctx, response, decoder.errorFactory); ok {
		return nil, respErr
	}
	resp := &httpbody.HttpBody{}
	if err := client.DecodeHttpBody(ctx, response, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

var _leo_goose_example_query_v1_Uint64Query_Uint64Query_Desc = &goose.Desc{
	RouteInfo: &goose.RouteInfo{
		HttpMethod: "GET",
		Pattern:    "/v1/uint64",
		FullMethod: "/leo.goose.example.query.v1.Uint64Query/Uint64Query",
	},
}

type FloatQueryService interface {
	FloatQuery(ctx context.Context, req *FloatQueryRequest) (*httpbody.HttpBody, error)
}

func AppendFloatQueryHttpRoute(router *http.ServeMux, service FloatQueryService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := floatQueryHandler{
		service: service,
		decoder: floatQueryRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: floatQueryResponseEncoder{
			marshalOptions:   options.MarshalOptions(),
			unmarshalOptions: options.UnmarshalOptions(),
		},
		errorEncoder:            options.ErrorEncoder(),
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              server.Chain(options.Middlewares()...),
	}
	router.Handle("GET /v1/float", http.HandlerFunc(handler.FloatQuery))
	return router
}

type floatQueryHandler struct {
	service                 FloatQueryService
	decoder                 floatQueryRequestDecoder
	encoder                 floatQueryResponseEncoder
	errorEncoder            goose.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              server.Middleware
}

func (h floatQueryHandler) FloatQuery(response http.ResponseWriter, request *http.Request) {
	invoke := func(response http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		req, err := h.decoder.FloatQuery(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := goose.ValidateRequest(ctx, req, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		resp, err := h.service.FloatQuery(ctx, req)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := h.encoder.FloatQuery(ctx, response, resp); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
	}
	server.Invoke(h.middleware, response, request, invoke, _leo_goose_example_query_v1_FloatQuery_FloatQuery_Desc.RouteInfo)
}

type floatQueryRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder floatQueryRequestDecoder) FloatQuery(ctx context.Context, request *http.Request) (*FloatQueryRequest, error) {
	req := &FloatQueryRequest{}
	ok, err := server.CustomDecodeRequest(ctx, request, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := request.URL.Query()
	var queryErr error
	req.Float, queryErr = goose.GetForm[float32](queryErr, queries, "float", goose.GetFloat)
	req.OptFloat, queryErr = goose.GetForm[*float32](queryErr, queries, "opt_float", goose.GetFloatPtr)
	req.WrapFloat, queryErr = goose.GetForm[*wrapperspb.FloatValue](queryErr, queries, "wrap_float", goose.GetFloat32Value)
	req.ListFloat, queryErr = goose.GetForm[[]float32](queryErr, queries, "list_float", goose.GetFloatSlice)
	req.ListWrapFloat, queryErr = goose.GetForm[[]*wrapperspb.FloatValue](queryErr, queries, "list_wrap_float", goose.GetFloat32ValueSlice)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type floatQueryResponseEncoder struct {
	marshalOptions   protojson.MarshalOptions
	unmarshalOptions protojson.UnmarshalOptions
}

func (encoder floatQueryResponseEncoder) FloatQuery(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

func NewFloatQueryHttpClient(target string, opts ...client.Option) FloatQueryService {
	options := client.NewOptions(opts...)
	client := &floatQueryHttpClient{
		client: options.Client(),
		encoder: floatQueryRequestEncoder{
			target:         target,
			marshalOptions: options.MarshalOptions(),
			resolver:       options.Resolver(),
		},
		decoder: floatQueryResponseDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
			errorDecoder:     options.ErrorDecoder(),
			errorFactory:     options.ErrorFactory(),
		},
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              client.Chain(options.Middlewares()...),
	}
	return client
}

type floatQueryHttpClient struct {
	client                  *http.Client
	encoder                 floatQueryRequestEncoder
	decoder                 floatQueryResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              client.Middleware
}

func (c *floatQueryHttpClient) FloatQuery(ctx context.Context, req *FloatQueryRequest) (*httpbody.HttpBody, error) {
	if err := goose.ValidateRequest(ctx, req, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	request, err := c.encoder.FloatQuery(ctx, req)
	if err != nil {
		return nil, err
	}
	response, err := client.Invoke(c.middleware, c.client, request, _leo_goose_example_query_v1_FloatQuery_FloatQuery_Desc.RouteInfo)
	if err != nil {
		return nil, err
	}
	resp, err := c.decoder.FloatQuery(ctx, response)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type floatQueryRequestEncoder struct {
	target         string
	marshalOptions protojson.MarshalOptions
	resolver       resolver.Resolver
}

func (encoder *floatQueryRequestEncoder) FloatQuery(ctx context.Context, req *FloatQueryRequest) (*http.Request, error) {
	if req == nil {
		return nil, errors.New("request is nil")
	}
	target, err := resolver.Resolve(ctx, encoder.resolver, encoder.target)
	if err != nil {
		return nil, err
	}
	method := "GET"
	header := http.Header{}
	var body bytes.Buffer
	path := "/v1/float"
	target.Path = path
	queries := url.Values{}
	queries["float"] = append(queries["float"], goose.FormatFloat(req.GetFloat(), 'f', -1, 32))
	queries["opt_float"] = append(queries["opt_float"], goose.FormatFloat(req.GetOptFloat(), 'f', -1, 32))
	queries["wrap_float"] = append(queries["wrap_float"], goose.FormatFloat(req.GetWrapFloat().GetValue(), 'f', -1, 32))
	queries["list_float"] = append(queries["list_float"], goose.FormatFloatSlice(req.GetListFloat(), 'f', -1, 32)...)
	queries["list_wrap_float"] = append(queries["list_wrap_float"], goose.FormatFloatSlice(goose.UnwrapFloat32Slice(req.GetListWrapFloat()), 'f', -1, 32)...)
	target.RawQuery = queries.Encode()
	request, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
	if err != nil {
		return nil, err
	}
	goose.CopyHeader(request.Header, header)
	return request, nil
}

type floatQueryResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
	errorDecoder     goose.ErrorDecoder
	errorFactory     goose.ErrorFactory
}

func (decoder *floatQueryResponseDecoder) FloatQuery(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	if respErr, ok := decoder.errorDecoder(ctx, response, decoder.errorFactory); ok {
		return nil, respErr
	}
	resp := &httpbody.HttpBody{}
	if err := client.DecodeHttpBody(ctx, response, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

var _leo_goose_example_query_v1_FloatQuery_FloatQuery_Desc = &goose.Desc{
	RouteInfo: &goose.RouteInfo{
		HttpMethod: "GET",
		Pattern:    "/v1/float",
		FullMethod: "/leo.goose.example.query.v1.FloatQuery/FloatQuery",
	},
}

type DoubleQueryService interface {
	DoubleQuery(ctx context.Context, req *DoubleQueryRequest) (*httpbody.HttpBody, error)
}

func AppendDoubleQueryHttpRoute(router *http.ServeMux, service DoubleQueryService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := doubleQueryHandler{
		service: service,
		decoder: doubleQueryRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: doubleQueryResponseEncoder{
			marshalOptions:   options.MarshalOptions(),
			unmarshalOptions: options.UnmarshalOptions(),
		},
		errorEncoder:            options.ErrorEncoder(),
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              server.Chain(options.Middlewares()...),
	}
	router.Handle("GET /v1/double", http.HandlerFunc(handler.DoubleQuery))
	return router
}

type doubleQueryHandler struct {
	service                 DoubleQueryService
	decoder                 doubleQueryRequestDecoder
	encoder                 doubleQueryResponseEncoder
	errorEncoder            goose.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              server.Middleware
}

func (h doubleQueryHandler) DoubleQuery(response http.ResponseWriter, request *http.Request) {
	invoke := func(response http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		req, err := h.decoder.DoubleQuery(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := goose.ValidateRequest(ctx, req, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		resp, err := h.service.DoubleQuery(ctx, req)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := h.encoder.DoubleQuery(ctx, response, resp); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
	}
	server.Invoke(h.middleware, response, request, invoke, _leo_goose_example_query_v1_DoubleQuery_DoubleQuery_Desc.RouteInfo)
}

type doubleQueryRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder doubleQueryRequestDecoder) DoubleQuery(ctx context.Context, request *http.Request) (*DoubleQueryRequest, error) {
	req := &DoubleQueryRequest{}
	ok, err := server.CustomDecodeRequest(ctx, request, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := request.URL.Query()
	var queryErr error
	req.Double, queryErr = goose.GetForm[float64](queryErr, queries, "double", goose.GetFloat)
	req.OptDouble, queryErr = goose.GetForm[*float64](queryErr, queries, "opt_double", goose.GetFloatPtr)
	req.WrapDouble, queryErr = goose.GetForm[*wrapperspb.DoubleValue](queryErr, queries, "wrap_double", goose.GetFloat64Value)
	req.ListDouble, queryErr = goose.GetForm[[]float64](queryErr, queries, "list_double", goose.GetFloatSlice)
	req.ListWrapDouble, queryErr = goose.GetForm[[]*wrapperspb.DoubleValue](queryErr, queries, "list_wrap_double", goose.GetFloat64ValueSlice)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type doubleQueryResponseEncoder struct {
	marshalOptions   protojson.MarshalOptions
	unmarshalOptions protojson.UnmarshalOptions
}

func (encoder doubleQueryResponseEncoder) DoubleQuery(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

func NewDoubleQueryHttpClient(target string, opts ...client.Option) DoubleQueryService {
	options := client.NewOptions(opts...)
	client := &doubleQueryHttpClient{
		client: options.Client(),
		encoder: doubleQueryRequestEncoder{
			target:         target,
			marshalOptions: options.MarshalOptions(),
			resolver:       options.Resolver(),
		},
		decoder: doubleQueryResponseDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
			errorDecoder:     options.ErrorDecoder(),
			errorFactory:     options.ErrorFactory(),
		},
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              client.Chain(options.Middlewares()...),
	}
	return client
}

type doubleQueryHttpClient struct {
	client                  *http.Client
	encoder                 doubleQueryRequestEncoder
	decoder                 doubleQueryResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              client.Middleware
}

func (c *doubleQueryHttpClient) DoubleQuery(ctx context.Context, req *DoubleQueryRequest) (*httpbody.HttpBody, error) {
	if err := goose.ValidateRequest(ctx, req, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	request, err := c.encoder.DoubleQuery(ctx, req)
	if err != nil {
		return nil, err
	}
	response, err := client.Invoke(c.middleware, c.client, request, _leo_goose_example_query_v1_DoubleQuery_DoubleQuery_Desc.RouteInfo)
	if err != nil {
		return nil, err
	}
	resp, err := c.decoder.DoubleQuery(ctx, response)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type doubleQueryRequestEncoder struct {
	target         string
	marshalOptions protojson.MarshalOptions
	resolver       resolver.Resolver
}

func (encoder *doubleQueryRequestEncoder) DoubleQuery(ctx context.Context, req *DoubleQueryRequest) (*http.Request, error) {
	if req == nil {
		return nil, errors.New("request is nil")
	}
	target, err := resolver.Resolve(ctx, encoder.resolver, encoder.target)
	if err != nil {
		return nil, err
	}
	method := "GET"
	header := http.Header{}
	var body bytes.Buffer
	path := "/v1/double"
	target.Path = path
	queries := url.Values{}
	queries["double"] = append(queries["double"], goose.FormatFloat(req.GetDouble(), 'f', -1, 64))
	queries["opt_double"] = append(queries["opt_double"], goose.FormatFloat(req.GetOptDouble(), 'f', -1, 64))
	queries["wrap_double"] = append(queries["wrap_double"], goose.FormatFloat(req.GetWrapDouble().GetValue(), 'f', -1, 64))
	queries["list_double"] = append(queries["list_double"], goose.FormatFloatSlice(req.GetListDouble(), 'f', -1, 64)...)
	queries["list_wrap_double"] = append(queries["list_wrap_double"], goose.FormatFloatSlice(goose.UnwrapFloat64Slice(req.GetListWrapDouble()), 'f', -1, 64)...)
	target.RawQuery = queries.Encode()
	request, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
	if err != nil {
		return nil, err
	}
	goose.CopyHeader(request.Header, header)
	return request, nil
}

type doubleQueryResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
	errorDecoder     goose.ErrorDecoder
	errorFactory     goose.ErrorFactory
}

func (decoder *doubleQueryResponseDecoder) DoubleQuery(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	if respErr, ok := decoder.errorDecoder(ctx, response, decoder.errorFactory); ok {
		return nil, respErr
	}
	resp := &httpbody.HttpBody{}
	if err := client.DecodeHttpBody(ctx, response, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

var _leo_goose_example_query_v1_DoubleQuery_DoubleQuery_Desc = &goose.Desc{
	RouteInfo: &goose.RouteInfo{
		HttpMethod: "GET",
		Pattern:    "/v1/double",
		FullMethod: "/leo.goose.example.query.v1.DoubleQuery/DoubleQuery",
	},
}

type StringQueryService interface {
	StringQuery(ctx context.Context, req *StringQueryRequest) (*httpbody.HttpBody, error)
}

func AppendStringQueryHttpRoute(router *http.ServeMux, service StringQueryService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := stringQueryHandler{
		service: service,
		decoder: stringQueryRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: stringQueryResponseEncoder{
			marshalOptions:   options.MarshalOptions(),
			unmarshalOptions: options.UnmarshalOptions(),
		},
		errorEncoder:            options.ErrorEncoder(),
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              server.Chain(options.Middlewares()...),
	}
	router.Handle("GET /v1/string", http.HandlerFunc(handler.StringQuery))
	return router
}

type stringQueryHandler struct {
	service                 StringQueryService
	decoder                 stringQueryRequestDecoder
	encoder                 stringQueryResponseEncoder
	errorEncoder            goose.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              server.Middleware
}

func (h stringQueryHandler) StringQuery(response http.ResponseWriter, request *http.Request) {
	invoke := func(response http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		req, err := h.decoder.StringQuery(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := goose.ValidateRequest(ctx, req, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		resp, err := h.service.StringQuery(ctx, req)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := h.encoder.StringQuery(ctx, response, resp); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
	}
	server.Invoke(h.middleware, response, request, invoke, _leo_goose_example_query_v1_StringQuery_StringQuery_Desc.RouteInfo)
}

type stringQueryRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder stringQueryRequestDecoder) StringQuery(ctx context.Context, request *http.Request) (*StringQueryRequest, error) {
	req := &StringQueryRequest{}
	ok, err := server.CustomDecodeRequest(ctx, request, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := request.URL.Query()
	var queryErr error
	req.String_ = queries.Get("string")
	req.OptString = proto.String(queries.Get("opt_string"))
	req.WrapString = wrapperspb.String(queries.Get("wrap_string"))
	req.ListString = queries["list_string"]
	req.ListWrapString = goose.WrapStringSlice(queries["list_wrap_string"])
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type stringQueryResponseEncoder struct {
	marshalOptions   protojson.MarshalOptions
	unmarshalOptions protojson.UnmarshalOptions
}

func (encoder stringQueryResponseEncoder) StringQuery(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

func NewStringQueryHttpClient(target string, opts ...client.Option) StringQueryService {
	options := client.NewOptions(opts...)
	client := &stringQueryHttpClient{
		client: options.Client(),
		encoder: stringQueryRequestEncoder{
			target:         target,
			marshalOptions: options.MarshalOptions(),
			resolver:       options.Resolver(),
		},
		decoder: stringQueryResponseDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
			errorDecoder:     options.ErrorDecoder(),
			errorFactory:     options.ErrorFactory(),
		},
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              client.Chain(options.Middlewares()...),
	}
	return client
}

type stringQueryHttpClient struct {
	client                  *http.Client
	encoder                 stringQueryRequestEncoder
	decoder                 stringQueryResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              client.Middleware
}

func (c *stringQueryHttpClient) StringQuery(ctx context.Context, req *StringQueryRequest) (*httpbody.HttpBody, error) {
	if err := goose.ValidateRequest(ctx, req, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	request, err := c.encoder.StringQuery(ctx, req)
	if err != nil {
		return nil, err
	}
	response, err := client.Invoke(c.middleware, c.client, request, _leo_goose_example_query_v1_StringQuery_StringQuery_Desc.RouteInfo)
	if err != nil {
		return nil, err
	}
	resp, err := c.decoder.StringQuery(ctx, response)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type stringQueryRequestEncoder struct {
	target         string
	marshalOptions protojson.MarshalOptions
	resolver       resolver.Resolver
}

func (encoder *stringQueryRequestEncoder) StringQuery(ctx context.Context, req *StringQueryRequest) (*http.Request, error) {
	if req == nil {
		return nil, errors.New("request is nil")
	}
	target, err := resolver.Resolve(ctx, encoder.resolver, encoder.target)
	if err != nil {
		return nil, err
	}
	method := "GET"
	header := http.Header{}
	var body bytes.Buffer
	path := "/v1/string"
	target.Path = path
	queries := url.Values{}
	queries["string"] = append(queries["string"], req.GetString_())
	queries["opt_string"] = append(queries["opt_string"], req.GetOptString())
	queries["wrap_string"] = append(queries["wrap_string"], req.GetWrapString().GetValue())
	queries["list_string"] = append(queries["list_string"], req.GetListString()...)
	queries["list_wrap_string"] = append(queries["list_wrap_string"], goose.UnwrapStringSlice(req.GetListWrapString())...)
	target.RawQuery = queries.Encode()
	request, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
	if err != nil {
		return nil, err
	}
	goose.CopyHeader(request.Header, header)
	return request, nil
}

type stringQueryResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
	errorDecoder     goose.ErrorDecoder
	errorFactory     goose.ErrorFactory
}

func (decoder *stringQueryResponseDecoder) StringQuery(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	if respErr, ok := decoder.errorDecoder(ctx, response, decoder.errorFactory); ok {
		return nil, respErr
	}
	resp := &httpbody.HttpBody{}
	if err := client.DecodeHttpBody(ctx, response, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

var _leo_goose_example_query_v1_StringQuery_StringQuery_Desc = &goose.Desc{
	RouteInfo: &goose.RouteInfo{
		HttpMethod: "GET",
		Pattern:    "/v1/string",
		FullMethod: "/leo.goose.example.query.v1.StringQuery/StringQuery",
	},
}

type EnumQueryService interface {
	EnumQuery(ctx context.Context, req *EnumQueryRequest) (*httpbody.HttpBody, error)
}

func AppendEnumQueryHttpRoute(router *http.ServeMux, service EnumQueryService, opts ...server.Option) *http.ServeMux {
	options := server.NewOptions(opts...)
	handler := enumQueryHandler{
		service: service,
		decoder: enumQueryRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: enumQueryResponseEncoder{
			marshalOptions:   options.MarshalOptions(),
			unmarshalOptions: options.UnmarshalOptions(),
		},
		errorEncoder:            options.ErrorEncoder(),
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              server.Chain(options.Middlewares()...),
	}
	router.Handle("GET /v1/enum", http.HandlerFunc(handler.EnumQuery))
	return router
}

type enumQueryHandler struct {
	service                 EnumQueryService
	decoder                 enumQueryRequestDecoder
	encoder                 enumQueryResponseEncoder
	errorEncoder            goose.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              server.Middleware
}

func (h enumQueryHandler) EnumQuery(response http.ResponseWriter, request *http.Request) {
	invoke := func(response http.ResponseWriter, request *http.Request) {
		ctx := request.Context()
		req, err := h.decoder.EnumQuery(ctx, request)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := goose.ValidateRequest(ctx, req, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		resp, err := h.service.EnumQuery(ctx, req)
		if err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
		if err := h.encoder.EnumQuery(ctx, response, resp); err != nil {
			h.errorEncoder(ctx, err, response)
			return
		}
	}
	server.Invoke(h.middleware, response, request, invoke, _leo_goose_example_query_v1_EnumQuery_EnumQuery_Desc.RouteInfo)
}

type enumQueryRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder enumQueryRequestDecoder) EnumQuery(ctx context.Context, request *http.Request) (*EnumQueryRequest, error) {
	req := &EnumQueryRequest{}
	ok, err := server.CustomDecodeRequest(ctx, request, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := request.URL.Query()
	var queryErr error
	req.Status, queryErr = goose.GetForm[EnumQueryRequest_Status](queryErr, queries, "status", goose.GetInt[EnumQueryRequest_Status])
	req.OptStatus, queryErr = goose.GetForm[*EnumQueryRequest_Status](queryErr, queries, "opt_status", goose.GetIntPtr[EnumQueryRequest_Status])
	req.ListStatus, queryErr = goose.GetForm[[]EnumQueryRequest_Status](queryErr, queries, "list_status", goose.GetIntSlice[EnumQueryRequest_Status])
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type enumQueryResponseEncoder struct {
	marshalOptions   protojson.MarshalOptions
	unmarshalOptions protojson.UnmarshalOptions
}

func (encoder enumQueryResponseEncoder) EnumQuery(ctx context.Context, w http.ResponseWriter, resp *httpbody.HttpBody) error {
	return server.EncodeHttpBody(ctx, w, resp)
}

func NewEnumQueryHttpClient(target string, opts ...client.Option) EnumQueryService {
	options := client.NewOptions(opts...)
	client := &enumQueryHttpClient{
		client: options.Client(),
		encoder: enumQueryRequestEncoder{
			target:         target,
			marshalOptions: options.MarshalOptions(),
			resolver:       options.Resolver(),
		},
		decoder: enumQueryResponseDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
			errorDecoder:     options.ErrorDecoder(),
			errorFactory:     options.ErrorFactory(),
		},
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
		middleware:              client.Chain(options.Middlewares()...),
	}
	return client
}

type enumQueryHttpClient struct {
	client                  *http.Client
	encoder                 enumQueryRequestEncoder
	decoder                 enumQueryResponseDecoder
	shouldFailFast          bool
	onValidationErrCallback goose.OnValidationErrCallback
	middleware              client.Middleware
}

func (c *enumQueryHttpClient) EnumQuery(ctx context.Context, req *EnumQueryRequest) (*httpbody.HttpBody, error) {
	if err := goose.ValidateRequest(ctx, req, c.shouldFailFast, c.onValidationErrCallback); err != nil {
		return nil, err
	}
	request, err := c.encoder.EnumQuery(ctx, req)
	if err != nil {
		return nil, err
	}
	response, err := client.Invoke(c.middleware, c.client, request, _leo_goose_example_query_v1_EnumQuery_EnumQuery_Desc.RouteInfo)
	if err != nil {
		return nil, err
	}
	resp, err := c.decoder.EnumQuery(ctx, response)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

type enumQueryRequestEncoder struct {
	target         string
	marshalOptions protojson.MarshalOptions
	resolver       resolver.Resolver
}

func (encoder *enumQueryRequestEncoder) EnumQuery(ctx context.Context, req *EnumQueryRequest) (*http.Request, error) {
	if req == nil {
		return nil, errors.New("request is nil")
	}
	target, err := resolver.Resolve(ctx, encoder.resolver, encoder.target)
	if err != nil {
		return nil, err
	}
	method := "GET"
	header := http.Header{}
	var body bytes.Buffer
	path := "/v1/enum"
	target.Path = path
	queries := url.Values{}
	queries["status"] = append(queries["status"], goose.FormatInt(req.GetStatus(), 10))
	queries["opt_status"] = append(queries["opt_status"], goose.FormatInt(req.GetOptStatus(), 10))
	queries["list_status"] = append(queries["list_status"], goose.FormatIntSlice(req.GetListStatus(), 10)...)
	target.RawQuery = queries.Encode()
	request, err := http.NewRequestWithContext(ctx, method, target.String(), &body)
	if err != nil {
		return nil, err
	}
	goose.CopyHeader(request.Header, header)
	return request, nil
}

type enumQueryResponseDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
	errorDecoder     goose.ErrorDecoder
	errorFactory     goose.ErrorFactory
}

func (decoder *enumQueryResponseDecoder) EnumQuery(ctx context.Context, response *http.Response) (*httpbody.HttpBody, error) {
	if respErr, ok := decoder.errorDecoder(ctx, response, decoder.errorFactory); ok {
		return nil, respErr
	}
	resp := &httpbody.HttpBody{}
	if err := client.DecodeHttpBody(ctx, response, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

var _leo_goose_example_query_v1_EnumQuery_EnumQuery_Desc = &goose.Desc{
	RouteInfo: &goose.RouteInfo{
		HttpMethod: "GET",
		Pattern:    "/v1/enum",
		FullMethod: "/leo.goose.example.query.v1.EnumQuery/EnumQuery",
	},
}
